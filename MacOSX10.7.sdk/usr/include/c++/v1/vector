// -*- C++ -*-
//===------------------------------ vector --------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_VECTOR
#define _LIBCPP_VECTOR

/*
    vector synopsis

namespace std
{

template <class T, class Allocator = allocator<T> >
class vector
{
public:
    typedef T                                        value_type;
    typedef Allocator                                allocator_type;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef implementation-defined                   iterator;
    typedef implementation-defined                   const_iterator;
    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef std::reverse_iterator<iterator>          reverse_iterator;
    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;

    explicit vector(const allocator_type& = allocator_type());
    explicit vector(size_type n);
    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());
    template <class InputIterator>
        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());
    vector(const vector& x);
    vector(vector&& x);
    vector(initializer_list<value_type> il);
    vector(initializer_list<value_type> il, const allocator_type& a);
    ~vector();
    vector& operator=(const vector& x);
    vector& operator=(vector&& x);
    vector& operator=(initializer_list<value_type> il);
    template <class InputIterator>
        void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const value_type& u);
    void assign(initializer_list<value_type> il);

    allocator_type get_allocator() const;

    iterator               begin();
    const_iterator         begin()   const;
    iterator               end();
    const_iterator         end()     const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin()  const;
    reverse_iterator       rend();
    const_reverse_iterator rend()    const;

    const_iterator         cbegin()  const;
    const_iterator         cend()    const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend()   const;

    size_type size() const;
    size_type max_size() const;
    size_type capacity() const;
    bool empty() const;
    void reserve(size_type n);
    void shrink_to_fit();

    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;

    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    value_type*       data();
    const value_type* data() const;

    void push_back(const value_type& x);
    void push_back(value_type&& x);
    template <class... Args>
        void emplace_back(Args&&... args);
    void pop_back();

    template <class... Args> iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    iterator insert(const_iterator position, size_type n, const value_type& x);
    template <class InputIterator>
        iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<value_type> il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);

    void clear();

    void resize(size_type sz);
    void resize(size_type sz, const value_type& c);

    void swap(vector&);

    bool __invariants() const;
};

template <class Allocator = allocator<T> >
class vector<bool, Allocator>
{
public:
    typedef bool                                     value_type;
    typedef Allocator                                allocator_type;
    typedef implementation-defined                   iterator;
    typedef implementation-defined                   const_iterator;
    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef iterator                                 pointer;
    typedef const_iterator                           const_pointer;
    typedef std::reverse_iterator<iterator>          reverse_iterator;
    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;

    class reference
    {
    public:
        reference(const reference&);
        operator bool() const;
        reference& operator=(const bool x);
        reference& operator=(const reference& x);
        iterator operator&() const;
        void flip();
    };

    class const_reference
    {
    public:
        const_reference(const reference&);
        operator bool() const;
        const_iterator operator&() const;
    };

    explicit vector(const allocator_type& = allocator_type());
    explicit vector(size_type n, const value_type& value = value_type(), const allocator_type& = allocator_type());
    template <class InputIterator>
        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());
    vector(const vector& x);
    vector(vector&& x);
    vector(initializer_list<value_type> il);
    vector(initializer_list<value_type> il, const allocator_type& a);
    ~vector();
    vector& operator=(const vector& x);
    vector& operator=(vector&& x);
    vector& operator=(initializer_list<value_type> il);
    template <class InputIterator>
        void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const value_type& u);
    void assign(initializer_list<value_type> il);

    allocator_type get_allocator() const;

    iterator               begin();
    const_iterator         begin()   const;
    iterator               end();
    const_iterator         end()     const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin()  const;
    reverse_iterator       rend();
    const_reverse_iterator rend()    const;

    const_iterator         cbegin()  const;
    const_iterator         cend()    const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend()   const;

    size_type size() const;
    size_type max_size() const;
    size_type capacity() const;
    bool empty() const;
    void reserve(size_type n);
    void shrink_to_fit();

    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;

    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    void push_back(const value_type& x);
    void pop_back();

    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, size_type n, const value_type& x);
    template <class InputIterator>
        iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<value_type> il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);

    void clear();

    void resize(size_type sz);
    void resize(size_type sz, value_type x);

    void swap(vector&);
    void flip();

    bool __invariants() const;
};

template <class Allocator> struct hash<std::vector<bool, Allocator>>;

template <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);

template <class T, class Allocator> void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);

}  // std

*/

#include <__config>
#include <__bit_reference>
#include <type_traits>
#include <climits>
#include <limits>
#include <initializer_list>
#include <memory>
#include <stdexcept>
#include <algorithm>
#include <cstring>
#include <__split_buffer>
#include <__functional_base>
#if defined(_LIBCPP_DEBUG) || defined(_LIBCPP_NO_EXCEPTIONS)
    #include <cassert>
#endif

#pragma GCC system_header

_LIBCPP_BEGIN_NAMESPACE_STD

template <bool>
class __vector_base_common
{
protected:
    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <bool __b>
void
__vector_base_common<__b>::__throw_length_error() const
{
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw length_error("vector");
#else
    assert(!"vector length_error");
#endif
}

template <bool __b>
void
__vector_base_common<__b>::__throw_out_of_range() const
{
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw out_of_range("vector");
#else
    assert(!"vector out_of_range");
#endif
}

extern template class __vector_base_common<true>;

template <class _Tp, class _Allocator>
class __vector_base
    : protected __vector_base_common<true>
{
protected:
    typedef _Tp                                      value_type;
    typedef _Allocator                               allocator_type;
    typedef allocator_traits<allocator_type>         __alloc_traits;
    typedef value_type&                              reference;
    typedef const value_type&                        const_reference;
    typedef typename __alloc_traits::size_type       size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer         pointer;
    typedef typename __alloc_traits::const_pointer   const_pointer;
    typedef pointer                                  iterator;
    typedef const_pointer                            const_iterator;

    pointer                                         __begin_;
    pointer                                         __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    _LIBCPP_INLINE_VISIBILITY allocator_type&       __alloc()         {return __end_cap_.second();}
    _LIBCPP_INLINE_VISIBILITY const allocator_type& __alloc() const   {return __end_cap_.second();}
    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap()       {return __end_cap_.first();}
    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const {return __end_cap_.first();}

    _LIBCPP_INLINE_VISIBILITY __vector_base();
    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);
    ~__vector_base();

    _LIBCPP_INLINE_VISIBILITY void clear() {__destruct_at_end(__begin_);}
    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __begin_);}

    _LIBCPP_INLINE_VISIBILITY void __destruct_at_end(const_pointer __new_last)
        {__destruct_at_end(__new_last, is_trivially_destructible<value_type>());}
    _LIBCPP_INLINE_VISIBILITY void __destruct_at_end(const_pointer __new_last, false_type);
    _LIBCPP_INLINE_VISIBILITY void __destruct_at_end(const_pointer __new_last, true_type);

    _LIBCPP_INLINE_VISIBILITY
    void __copy_assign_alloc(const __vector_base& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    _LIBCPP_INLINE_VISIBILITY
    void __move_assign_alloc(__vector_base& __c)
        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    _LIBCPP_INLINE_VISIBILITY
    static void __swap_alloc(allocator_type& __x, allocator_type& __y)
        {__swap_alloc(__x, __y, integral_constant<bool,
                      __alloc_traits::propagate_on_container_swap::value>());}
private:
    _LIBCPP_INLINE_VISIBILITY
    void __copy_assign_alloc(const __vector_base& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
            {
                clear();
                __alloc_traits::deallocate(__alloc(), __begin_, capacity());
                __begin_ = __end_ = __end_cap() = nullptr;
            }
            __alloc() = __c.__alloc();
        }

    _LIBCPP_INLINE_VISIBILITY
    void __copy_assign_alloc(const __vector_base& __c, false_type)
        {}

    _LIBCPP_INLINE_VISIBILITY
    void __move_assign_alloc(const __vector_base& __c, true_type)
        {
            __alloc() = _STD::move(__c.__alloc());
        }

    _LIBCPP_INLINE_VISIBILITY
    void __move_assign_alloc(const __vector_base& __c, false_type)
        {}

    _LIBCPP_INLINE_VISIBILITY
    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)
        {
            using _STD::swap;
            swap(__x, __y);
        }
    _LIBCPP_INLINE_VISIBILITY
    static void __swap_alloc(allocator_type& __x, allocator_type& __y, false_type)
        {}
};

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
void
__vector_base<_Tp, _Allocator>::__destruct_at_end(const_pointer __new_last, false_type)
{
    while (__new_last < __end_)
        __alloc_traits::destroy(__alloc(), const_cast<pointer>(--__end_));
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
void
__vector_base<_Tp, _Allocator>::__destruct_at_end(const_pointer __new_last, true_type)
{
    __end_ = const_cast<pointer>(__new_last);
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
__vector_base<_Tp, _Allocator>::__vector_base()
    : __begin_(0),
      __end_(0),
      __end_cap_(0)
{
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)
    : __begin_(0),
      __end_(0),
      __end_cap_(0, __a)
{
}

template <class _Tp, class _Allocator>
__vector_base<_Tp, _Allocator>::~__vector_base()
{
    if (__begin_ != 0)
    {
        clear();
        __alloc_traits::deallocate(__alloc(), __begin_, capacity());
    }
}

template <class _Tp, class _Allocator = allocator<_Tp> >
class _LIBCPP_VISIBLE vector
    : private __vector_base<_Tp, _Allocator>
{
private:
    typedef __vector_base<_Tp, _Allocator>           __base;
public:
    typedef vector                                   __self;
    typedef _Tp                                      value_type;
    typedef _Allocator                               allocator_type;
    typedef typename __base::__alloc_traits          __alloc_traits;
    typedef typename __base::reference               reference;
    typedef typename __base::const_reference         const_reference;
    typedef typename __base::size_type               size_type;
    typedef typename __base::difference_type         difference_type;
    typedef typename __base::pointer                 pointer;
    typedef typename __base::const_pointer           const_pointer;
#ifdef _LIBCPP_DEBUG
    typedef __debug_iter<vector, pointer>            iterator;
    typedef __debug_iter<vector, const_pointer>      const_iterator;

    friend class __debug_iter<vector, pointer>;
    friend class __debug_iter<vector, const_pointer>;

    pair<iterator*, const_iterator*> __iterator_list_;

    _LIBCPP_INLINE_VISIBILITY iterator*&       __get_iterator_list(iterator*)       {return __iterator_list_.first;}
    _LIBCPP_INLINE_VISIBILITY const_iterator*& __get_iterator_list(const_iterator*) {return __iterator_list_.second;}
#elif defined(_LIBCPP_RAW_ITERATORS)
    typedef pointer                                  iterator;
    typedef const_pointer                            const_iterator;
#else  // defined(_LIBCPP_RAW_ITERATORS)
    typedef __wrap_iter<pointer>                     iterator;
    typedef __wrap_iter<const_pointer>               const_iterator;
#endif  // defined(_LIBCPP_RAW_ITERATORS)
    typedef _STD::reverse_iterator<iterator>         reverse_iterator;
    typedef _STD::reverse_iterator<const_iterator>   const_reverse_iterator;

    _LIBCPP_INLINE_VISIBILITY vector() {}
    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a) : __base(__a) {}
    explicit vector(size_type __n);
    vector(size_type __n, const_reference __x);
    vector(size_type __n, const_reference __x, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               typename enable_if<__is_input_iterator  <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_input_iterator  <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);
    _LIBCPP_INLINE_VISIBILITY
    vector(initializer_list<value_type> __il);
    _LIBCPP_INLINE_VISIBILITY
    vector(initializer_list<value_type> __il, const allocator_type& __a);
#ifdef _LIBCPP_DEBUG
    _LIBCPP_INLINE_VISIBILITY
    ~vector() {__invalidate_all_iterators();}
#endif

    vector(const vector& __x);
    vector(const vector& __x, const allocator_type& __a);
    _LIBCPP_INLINE_VISIBILITY
    vector& operator=(const vector& __x);
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY
    vector(vector&& __x);
    _LIBCPP_INLINE_VISIBILITY
    vector(vector&& __x, const allocator_type& __a);
    _LIBCPP_INLINE_VISIBILITY
    vector& operator=(vector&& __x);
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}

    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator  <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const_reference __u);
    _LIBCPP_INLINE_VISIBILITY
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}

    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const {return this->__alloc();}

    _LIBCPP_INLINE_VISIBILITY iterator               begin();
    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const;
    _LIBCPP_INLINE_VISIBILITY iterator               end();
    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const;

    _LIBCPP_INLINE_VISIBILITY reverse_iterator       rbegin()         {return       reverse_iterator(end());}
    _LIBCPP_INLINE_VISIBILITY const_reverse_iterator rbegin()  const  {return const_reverse_iterator(end());}
    _LIBCPP_INLINE_VISIBILITY reverse_iterator       rend()           {return       reverse_iterator(begin());}
    _LIBCPP_INLINE_VISIBILITY const_reverse_iterator rend()    const  {return const_reverse_iterator(begin());}

    _LIBCPP_INLINE_VISIBILITY const_iterator         cbegin()  const  {return begin();}
    _LIBCPP_INLINE_VISIBILITY const_iterator         cend()    const  {return end();}
    _LIBCPP_INLINE_VISIBILITY const_reverse_iterator crbegin() const  {return rbegin();}
    _LIBCPP_INLINE_VISIBILITY const_reverse_iterator crend()   const  {return rend();}

    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(this->__end_ - this->__begin_);}
    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return __base::capacity();}
    _LIBCPP_INLINE_VISIBILITY bool empty() const {return this->__begin_ == this->__end_;}
    size_type max_size() const;
    void reserve(size_type __n);
    void shrink_to_fit();

    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);
    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;
    reference       at(size_type __n);
    const_reference at(size_type __n) const;

    _LIBCPP_INLINE_VISIBILITY reference       front()       {return *this->__begin_;}
    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *this->__begin_;}
    _LIBCPP_INLINE_VISIBILITY reference       back()        {return *(this->__end_ - 1);}
    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return *(this->__end_ - 1);}

    _LIBCPP_INLINE_VISIBILITY value_type*       data()
        {return _STD::__to_raw_pointer(this->__begin_);}
    _LIBCPP_INLINE_VISIBILITY const value_type* data() const
        {return _STD::__to_raw_pointer(this->__begin_);}

    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    void push_back(value_type&& __x);
#ifndef _LIBCPP_HAS_NO_VARIADICS
    template <class... _Args>
        void emplace_back(_Args&&... __args);
#endif  // _LIBCPP_HAS_NO_VARIADICS
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    void pop_back();

    iterator insert(const_iterator __position, const_reference __x);
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    iterator insert(const_iterator __position, value_type&& __x);
#ifndef _LIBCPP_HAS_NO_VARIADICS
    template <class... _Args>
        iterator emplace(const_iterator __position, _Args&&... __args);
#endif  // _LIBCPP_HAS_NO_VARIADICS
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator  <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
    _LIBCPP_INLINE_VISIBILITY
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}

    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    _LIBCPP_INLINE_VISIBILITY void clear() {__base::clear();}

    void resize(size_type __sz);
    void resize(size_type __sz, const_reference __x);

    void swap(vector&);

    bool __invariants() const;

private:
    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();
    void allocate(size_type __n);
    void deallocate();
    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;
    void __construct_at_end(size_type __n);
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    void __move_construct_at_end(pointer __first, pointer __last);
    void __append(size_type __n);
    void __append(size_type __n, const_reference __x);
    _LIBCPP_INLINE_VISIBILITY
    iterator       __make_iter(pointer __p);
    _LIBCPP_INLINE_VISIBILITY
    const_iterator __make_iter(const_pointer __p) const;
    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
    void __move_range(pointer __from_s, pointer __from_e, pointer __to);
    void __move_assign(vector& __c, true_type);
    void __move_assign(vector& __c, false_type);
};

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)
{
    for (pointer __p = this->__end_; this->__begin_ < __p;)
        __v.push_front(_STD::move(*--__p));
    _STD::swap(this->__begin_, __v.__begin_);
    _STD::swap(this->__end_, __v.__end_);
    _STD::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)
{
    pointer __r = __v.__begin_;
    for (pointer __i = __p; this->__begin_ < __i;)
        __v.push_front(_STD::move(*--__i));
    for (pointer __i = __p; __i < this->__end_; ++__i)
        __v.push_back(_STD::move(*__i));
    _STD::swap(this->__begin_, __v.__begin_);
    _STD::swap(this->__end_, __v.__end_);
    _STD::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __invalidate_all_iterators();
    return __r;
}

//  Allocate space for __n objects
//  throws length_error if __n > max_size()
//  throws (probably bad_alloc) if memory run out
//  Precondition:  __begin_ == __end_ == __end_cap() == 0
//  Precondition:  __n > 0
//  Postcondition:  capacity() == __n
//  Postcondition:  size() == 0
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::allocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);
    this->__end_cap() = this->__begin_ + __n;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::deallocate()
{
    if (this->__begin_ != 0)
    {
        clear();
        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
        __invalidate_all_iterators();
        this->__begin_ = this->__end_ = this->__end_cap() = 0;
    }
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const
{
    return _STD::min(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);  // end() >= begin(), always
}

//  Precondition:  __new_size > capacity()
template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return _STD::max(2*__cap, __new_size);
}

//  Default constructs __n objects starting at __end_
//  throws if construction throws
//  Precondition:  __n > 0
//  Precondition:  size() + __n <= capacity()
//  Postcondition:  size() == size() + __n
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    allocator_type& __a = this->__alloc();
    do
    {
        __alloc_traits::construct(__a, _STD::__to_raw_pointer(this->__end_));
        ++this->__end_;
        --__n;
    } while (__n > 0);
}

//  Copy constructs __n objects starting at __end_ from __x
//  throws if construction throws
//  Precondition:  __n > 0
//  Precondition:  size() + __n <= capacity()
//  Postcondition:  size() == old size() + __n
//  Postcondition:  [i] == __x for all i in [size() - __n, __n)
template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    allocator_type& __a = this->__alloc();
    do
    {
        __alloc_traits::construct(__a, _STD::__to_raw_pointer(this->__end_), __x);
        ++this->__end_;
        --__n;
    } while (__n > 0);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    allocator_type& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        __alloc_traits::construct(__a, _STD::__to_raw_pointer(this->__end_), *__first);
        ++this->__end_;
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_construct_at_end(pointer __first, pointer __last)
{
    allocator_type& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        __alloc_traits::construct(__a, _STD::__to_raw_pointer(this->__end_),
                                  _STD::move(*__first));
        ++this->__end_;
    }
}

//  Default constructs __n objects starting at __end_
//  throws if construction throws
//  Postcondition:  size() == size() + __n
//  Exception safety: strong but assumes move ctor doesn't throw (copy ctor can)
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n);
        __swap_out_circular_buffer(__v);
    }
}

//  Default constructs __n objects starting at __end_
//  throws if construction throws
//  Postcondition:  size() == size() + __n
//  Exception safety: strong but assumes move ctor doesn't throw (copy ctor can)
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n, __x);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n, __x);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n)
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)
    : __base(__a)
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last,
       typename enable_if<__is_input_iterator  <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value>::type*)
{
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_input_iterator  <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value>::type*)
    : __base(__a)
{
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)
{
    size_type __n = static_cast<size_type>(_STD::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)
    : __base(__a)
{
    size_type __n = static_cast<size_type>(_STD::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x)
    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))
{
    size_type __n = __x.size();
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)
    : __base(__a)
{
    size_type __n = __x.size();
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_);
    }
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<_Tp, _Allocator>::vector(vector&& __x)
    : __base(_STD::move(__x.__alloc()))
{
    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = 0;
    __x.__invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)
    : __base(__a)
{
    if (__a == __x.__alloc())
    {
        this->__begin_ = __x.__begin_;
        this->__end_ = __x.__end_;
        this->__end_cap() = __x.__end_cap();
        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
        __x.__invalidate_all_iterators();
    }
    else
    {
        typedef move_iterator<iterator> _I;
        assign(_I(__x.begin()), _I(__x.end()));
    }
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)
{
    if (__il.size() > 0)
    {
        allocate(__il.size());
        __construct_at_end(__il.begin(), __il.end());
    }
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __base(__a)
{
    if (__il.size() > 0)
    {
        allocate(__il.size());
        __construct_at_end(__il.begin(), __il.end());
    }
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(vector&& __x)
{
    __move_assign(__x, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)
{
    if (__base::__alloc() != __c.__alloc())
    {
        typedef move_iterator<iterator> _I;
        assign(_I(__c.begin()), _I(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)
{
    deallocate();
    this->__begin_ = __c.__begin_;
    this->__end_ = __c.__end_;
    this->__end_cap() = __c.__end_cap();
    __base::__move_assign_alloc(__c);
    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
}

#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(const vector& __x)
{
    if (this != &__x)
    {
        __base::__copy_assign_alloc(__x);
        assign(__x.__begin_, __x.__end_);
    }
    return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator  <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    typename iterator_traits<_ForwardIterator>::difference_type __new_size = _STD::distance(__first, __last);
    if (static_cast<size_type>(__new_size) <= capacity())
    {
        _ForwardIterator __mid = __last;
        bool __growing = false;
        if (static_cast<size_type>(__new_size) > size())
        {
            __growing = true;
            __mid =  __first;
            _STD::advance(__mid, size());
        }
        pointer __m = _STD::copy(__first, __mid, this->__begin_);
        if (__growing)
            __construct_at_end(__mid, __last);
        else
            this->__destruct_at_end(__m);
    }
    else
    {
        deallocate();
        allocate(__recommend(static_cast<size_type>(__new_size)));
        __construct_at_end(__first, __last);
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)
{
    if (__n <= capacity())
    {
        size_type __s = size();
        _STD::fill_n(this->__begin_, _STD::min(__n, __s), __u);
        if (__n > __s)
            __construct_at_end(__n - __s, __u);
        else
            this->__destruct_at_end(this->__begin_ + __n);
    }
    else
    {
        deallocate();
        allocate(__recommend(static_cast<size_type>(__n)));
        __construct_at_end(__n, __u);
    }
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__make_iter(pointer __p)
{
#ifdef _LIBCPP_DEBUG
    return iterator(this, __p);
#else
    return iterator(__p);
#endif
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::__make_iter(const_pointer __p) const
{
#ifdef _LIBCPP_DEBUG
    return const_iterator(this, __p);
#else
    return const_iterator(__p);
#endif
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin()
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end()
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n)
{
#ifdef _LIBCPP_DEBUG
    assert(__n < size());
#endif
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const
{
#ifdef _LIBCPP_DEBUG
    assert(__n < size());
#endif
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__n, 0, __a);
        __v.__construct_at_end(move_iterator<pointer>(this->__begin_),
                               move_iterator<pointer>(this->__end_));
        clear();
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::shrink_to_fit()
{
    if (capacity() > size())
    {
#ifndef _LIBCPP_NO_EXCEPTIONS
        try
        {
#endif  // _LIBCPP_NO_EXCEPTIONS
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(size(), 0, __a);
            __v.__construct_at_end(move_iterator<pointer>(this->__begin_),
                                   move_iterator<pointer>(this->__end_));
            clear();
            __swap_out_circular_buffer(__v);
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
        catch (...)
        {
        }
#endif  // _LIBCPP_NO_EXCEPTIONS
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (this->__end_ < this->__end_cap())
    {
        __alloc_traits::construct(this->__alloc(),
                                  _STD::__to_raw_pointer(this->__end_), __x);
        ++this->__end_;
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);
        __v.push_back(__x);
        __swap_out_circular_buffer(__v);
    }
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (this->__end_ < this->__end_cap())
    {
        __alloc_traits::construct(this->__alloc(),
                                  _STD::__to_raw_pointer(this->__end_),
                                  _STD::move(__x));
        ++this->__end_;
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);
        __v.push_back(_STD::move(__x));
        __swap_out_circular_buffer(__v);
    }
}

#ifndef _LIBCPP_HAS_NO_VARIADICS

template <class _Tp, class _Allocator>
template <class... _Args>
void
vector<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (this->__end_ < this->__end_cap())
    {
        __alloc_traits::construct(this->__alloc(),
                                  _STD::__to_raw_pointer(this->__end_),
                                  _STD::forward<_Args>(__args)...);
        ++this->__end_;
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);
        __v.emplace_back(_STD::forward<_Args>(__args)...);
        __swap_out_circular_buffer(__v);
    }
}

#endif  // _LIBCPP_HAS_NO_VARIADICS
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
void
vector<_Tp, _Allocator>::pop_back()
{
    this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position)
{
    pointer __p = const_cast<pointer>(&*__position);
    iterator __r = __make_iter(__p);
    this->__destruct_at_end(_STD::move(__p + 1, this->__end_, __p));
    return __r;
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    pointer __p = this->__begin_ + (__first - begin());
    iterator __r = __make_iter(__p);
    this->__destruct_at_end(_STD::move(__p + (__last - __first), this->__end_, __p));
    return __r;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)
{
    pointer __old_last = this->__end_;
    difference_type __n = __old_last - __to;
    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)
        __alloc_traits::construct(this->__alloc(),
                                  _STD::__to_raw_pointer(this->__end_),
                                  _STD::move(*__i));
    _STD::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)
{
    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __alloc_traits::construct(this->__alloc(),
                                      _STD::__to_raw_pointer(this->__end_), __x);
            ++this->__end_;
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
            if (__p <= __xr && __xr < this->__end_)
                ++__xr;
            *__p = *__xr;
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(__x);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)
{
    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __alloc_traits::construct(this->__alloc(),
                                      _STD::__to_raw_pointer(this->__end_),
                                      _STD::move(__x));
            ++this->__end_;
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            *__p = _STD::move(__x);
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(_STD::move(__x));
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

#ifndef _LIBCPP_HAS_NO_VARIADICS

template <class _Tp, class _Allocator>
template <class... _Args>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)
{
    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __alloc_traits::construct(this->__alloc(),
                                      _STD::__to_raw_pointer(this->__end_),
                                      _STD::forward<_Args>(__args)...);
            ++this->__end_;
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            *__p = value_type(_STD::forward<_Args>(__args)...);
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.emplace_back(_STD::forward<_Args>(__args)...);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

#endif  // _LIBCPP_HAS_NO_VARIADICS
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)
{
    pointer __p = this->__begin_ + (__position - begin());
    if (__n > 0)
    {
        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            if (__n > static_cast<size_type>(this->__end_ - __p))
            {
                size_type __cx = __n - (this->__end_ - __p);
                __construct_at_end(__cx, __x);
                __n -= __cx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                if (__p <= __xr && __xr < this->__end_)
                    __xr += __old_n;
                _STD::fill_n(__p, __n, *__xr);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__n, __x);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator  <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
    difference_type __off = __position - begin();
    pointer __p = this->__begin_ + __off;
    allocator_type& __a = this->__alloc();
    pointer __old_last = this->__end_;
    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)
    {
        __alloc_traits::construct(__a, _STD::__to_raw_pointer(this->__end_),
                                  *__first);
        ++this->__end_;
    }
    __split_buffer<value_type, allocator_type&> __v(__a);
    if (__first != __last)
    {
#ifndef _LIBCPP_NO_EXCEPTIONS
        try
        {
#endif  // _LIBCPP_NO_EXCEPTIONS
            __v.__construct_at_end(__first, __last);
            difference_type __old_size = __old_last - this->__begin_;
            difference_type __old_p = __p - this->__begin_;
            reserve(__recommend(size() + __v.size()));
            __p = this->__begin_ + __old_p;
            __old_last = this->__begin_ + __old_size;
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
        catch (...)
        {
            erase(__make_iter(__old_last), end());
            throw;
        }
#endif  // _LIBCPP_NO_EXCEPTIONS
    }
    __p = _STD::rotate(__p, __old_last, this->__end_);
    insert(__make_iter(__p), move_iterator<iterator>(__v.begin()),
                                    move_iterator<iterator>(__v.end()));
    return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
    pointer __p = this->__begin_ + (__position - begin());
    difference_type __n = _STD::distance(__first, __last);
    if (__n > 0)
    {
        if (__n <= this->__end_cap() - this->__end_)
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            _ForwardIterator __m = __last;
            difference_type __dx = this->__end_ - __p;
            if (__n > __dx)
            {
                __m = __first;
                _STD::advance(__m, this->__end_ - __p);
                __construct_at_end(__m, __last);
                __n = __dx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                _STD::copy(__first, __m, __p);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__first, __last);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs, __x);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::swap(vector& __x)
{
    _STD::swap(this->__begin_, __x.__begin_);
    _STD::swap(this->__end_, __x.__end_);
    _STD::swap(this->__end_cap(), __x.__end_cap());
    __base::__swap_alloc(this->__alloc(), __x.__alloc());
#ifdef _LIBCPP_DEBUG
    iterator::swap(this, &__x);
    const_iterator::swap(this, &__x);
#endif  // _LIBCPP_DEBUG
}

template <class _Tp, class _Allocator>
bool
vector<_Tp, _Allocator>::__invariants() const
{
    if (this->__begin_ == 0)
    {
        if (this->__end_ != 0 || this->__end_cap() != 0)
            return false;
    }
    else
    {
        if (this->__begin_ > this->__end_)
            return false;
        if (this->__begin_ == this->__end_cap())
            return false;
        if (this->__end_ > this->__end_cap())
            return false;
    }
    return true;
}

template <class _Tp, class _Allocator>
#ifndef _LIBCPP_DEBUG
_LIBCPP_INLINE_VISIBILITY inline
#endif
void
vector<_Tp, _Allocator>::__invalidate_all_iterators()
{
#ifdef _LIBCPP_DEBUG
    iterator::__remove_all(this);
    const_iterator::__remove_all(this);
#endif  // _LIBCPP_DEBUG
}

// vector<bool>

template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator> >;

template <class _Allocator>
class _LIBCPP_VISIBLE vector<bool, _Allocator>
    : private __vector_base_common<true>
{
public:
    typedef vector                                   __self;
    typedef bool                                     value_type;
    typedef _Allocator                               allocator_type;
    typedef allocator_traits<allocator_type>         __alloc_traits;
    typedef __bit_reference<vector>                  reference;
    typedef __bit_const_reference<vector>            const_reference;
    typedef typename __alloc_traits::size_type       size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __bit_iterator<vector, false>            pointer;
    typedef __bit_iterator<vector, true>             const_pointer;
#ifdef _LIBCPP_DEBUG
    typedef __debug_iter<vector, pointer>            iterator;
    typedef __debug_iter<vector, const_pointer>      const_iterator;

    friend class __debug_iter<vector, pointer>;
    friend class __debug_iter<vector, const_pointer>;

    pair<iterator*, const_iterator*> __iterator_list_;

    _LIBCPP_INLINE_VISIBILITY iterator*&       __get_iterator_list(iterator*)       {return __iterator_list_.first;}
    _LIBCPP_INLINE_VISIBILITY const_iterator*& __get_iterator_list(const_iterator*) {return __iterator_list_.second;}
#else  // _LIBCPP_DEBUG
    typedef pointer                                  iterator;
    typedef const_pointer                            const_iterator;
#endif  // _LIBCPP_DEBUG
    typedef _STD::reverse_iterator<iterator>         reverse_iterator;
    typedef _STD::reverse_iterator<const_iterator>   const_reverse_iterator;

private:
    typedef size_type __storage_type;
    typedef typename __alloc_traits::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
                rebind_alloc<__storage_type>
#else
                rebind_alloc<__storage_type>::other
#endif
                                                     __storage_allocator;
    typedef allocator_traits<__storage_allocator>    __storage_traits;
    typedef typename __storage_traits::pointer       __storage_pointer;
    typedef typename __storage_traits::const_pointer __const_storage_pointer;

    __storage_pointer                                      __begin_;
    size_type                                              __size_;
    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;

    _LIBCPP_INLINE_VISIBILITY       size_type&           __cap()         {return __cap_alloc_.first();}
    _LIBCPP_INLINE_VISIBILITY const size_type&           __cap()   const {return __cap_alloc_.first();}
    _LIBCPP_INLINE_VISIBILITY       __storage_allocator& __alloc()       {return __cap_alloc_.second();}
    _LIBCPP_INLINE_VISIBILITY const __storage_allocator& __alloc() const {return __cap_alloc_.second();}

    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);

    _LIBCPP_INLINE_VISIBILITY static size_type __internal_cap_to_external(size_type __n)
        {return __n * __bits_per_word;}
    _LIBCPP_INLINE_VISIBILITY static size_type __external_cap_to_internal(size_type __n)
        {return (__n - 1) / __bits_per_word + 1;}

public:
    _LIBCPP_INLINE_VISIBILITY vector();
    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a);
    ~vector();
    explicit vector(size_type __n);
    vector(size_type __n, const value_type& __v);
    vector(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               typename enable_if<__is_input_iterator  <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_input_iterator  <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);

    vector(const vector& __v);
    vector(const vector& __v, const allocator_type& __a);
    vector& operator=(const vector& __v);
    vector(initializer_list<value_type> __il);
    vector(initializer_list<value_type> __il, const allocator_type& __a);

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY vector(vector&& __v);
    vector(vector&& __v, const allocator_type& __a);
    _LIBCPP_INLINE_VISIBILITY vector& operator=(vector&& __v);
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}

    template <class _InputIterator>
        typename enable_if
        <
            __is_input_iterator<_InputIterator>::value &&
           !__is_forward_iterator<_InputIterator>::value,
           void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
           void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const value_type& __x);
    _LIBCPP_INLINE_VISIBILITY
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}

    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const
        {return allocator_type(this->__alloc());}

    size_type max_size() const;
    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return __internal_cap_to_external(__cap());}
    _LIBCPP_INLINE_VISIBILITY size_type size() const {return __size_;}
    _LIBCPP_INLINE_VISIBILITY bool empty() const {return __size_ == 0;}
    void reserve(size_type __n);
    void shrink_to_fit();

    _LIBCPP_INLINE_VISIBILITY       iterator begin()       {return __make_iter(0);}
    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const {return __make_iter(0);}
    _LIBCPP_INLINE_VISIBILITY       iterator end()         {return __make_iter(__size_);}
    _LIBCPP_INLINE_VISIBILITY const_iterator end()   const {return __make_iter(__size_);}

    _LIBCPP_INLINE_VISIBILITY       reverse_iterator rbegin()       {return       reverse_iterator(end());}
    _LIBCPP_INLINE_VISIBILITY const_reverse_iterator rbegin() const {return const_reverse_iterator(end());}
    _LIBCPP_INLINE_VISIBILITY       reverse_iterator rend()         {return       reverse_iterator(begin());}
    _LIBCPP_INLINE_VISIBILITY const_reverse_iterator rend()   const {return const_reverse_iterator(begin());}

    _LIBCPP_INLINE_VISIBILITY const_iterator         cbegin()  const {return __make_iter(0);}
    _LIBCPP_INLINE_VISIBILITY const_iterator         cend()    const {return __make_iter(__size_);}
    _LIBCPP_INLINE_VISIBILITY const_reverse_iterator crbegin() const {return rbegin();}
    _LIBCPP_INLINE_VISIBILITY const_reverse_iterator crend()   const {return rend();}

    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}
    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}
    reference       at(size_type __n);
    const_reference at(size_type __n) const;

    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}
    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}
    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}
    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}

    void push_back(const value_type& __x);
    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}

    iterator insert(const_iterator __position, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator  <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
    _LIBCPP_INLINE_VISIBILITY
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}

    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    _LIBCPP_INLINE_VISIBILITY void clear() {__size_ = 0;}

    void swap(vector&);

    void resize(size_type __sz, value_type __x = false);
    void flip();

    bool __invariants() const;

private:
    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();
    void allocate(size_type __n);
    void deallocate();
    _LIBCPP_INLINE_VISIBILITY static size_type __align(size_type __new_size)
        {return __new_size + (__bits_per_word-1) & ~(__bits_per_word-1);};
    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;
    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    void __append(size_type __n, const_reference __x);
    _LIBCPP_INLINE_VISIBILITY reference __make_ref(size_type __pos)
        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    _LIBCPP_INLINE_VISIBILITY const_reference __make_ref(size_type __pos) const
        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
#ifdef _LIBCPP_DEBUG
    _LIBCPP_INLINE_VISIBILITY iterator __make_iter(size_type __pos)
        {return iterator(this, pointer(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word)));}
    _LIBCPP_INLINE_VISIBILITY const_iterator __make_iter(size_type __pos) const
        {return const_iterator(this, const_pointer(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word)));}
    _LIBCPP_INLINE_VISIBILITY iterator __const_iterator_cast(const_iterator __p)
        {return iterator(this, pointer(const_cast<__storage_pointer>(__p.base().__seg_), __p.base().__ctz_));}
#else  // _LIBCPP_DEBUG
    _LIBCPP_INLINE_VISIBILITY iterator __make_iter(size_type __pos)
        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    _LIBCPP_INLINE_VISIBILITY const_iterator __make_iter(size_type __pos) const
        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    _LIBCPP_INLINE_VISIBILITY iterator __const_iterator_cast(const_iterator __p)
        {return iterator(const_cast<__storage_pointer>(__p.__seg_), __p.__ctz_);}
#endif  // _LIBCPP_DEBUG

    _LIBCPP_INLINE_VISIBILITY
    void __copy_assign_alloc(const vector& __v)
        {__copy_assign_alloc(__v, integral_constant<bool,
                      __storage_traits::propagate_on_container_copy_assignment::value>());}
    _LIBCPP_INLINE_VISIBILITY
    void __copy_assign_alloc(const vector& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
                deallocate();
            __alloc() = __c.__alloc();
        }

    _LIBCPP_INLINE_VISIBILITY
    void __copy_assign_alloc(const vector& __c, false_type)
        {}

    void __move_assign(vector& __c, false_type);
    void __move_assign(vector& __c, true_type);
    _LIBCPP_INLINE_VISIBILITY
    void __move_assign_alloc(vector& __c)
        {__move_assign_alloc(__c, integral_constant<bool,
                      __storage_traits::propagate_on_container_move_assignment::value>());}
    _LIBCPP_INLINE_VISIBILITY
    void __move_assign_alloc(const vector& __c, true_type)
        {
            __alloc() = _STD::move(__c.__alloc());
        }

    _LIBCPP_INLINE_VISIBILITY
    void __move_assign_alloc(const vector& __c, false_type)
        {}

    _LIBCPP_INLINE_VISIBILITY
    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y)
        {__swap_alloc(__x, __y, integral_constant<bool,
                      __storage_traits::propagate_on_container_swap::value>());}

    _LIBCPP_INLINE_VISIBILITY
    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y, true_type)
        {
            using _STD::swap;
            swap(__x, __y);
        }
    _LIBCPP_INLINE_VISIBILITY
    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y, false_type)
        {}

    size_t __hash_code() const;

    friend class __bit_reference<vector>;
    friend class __bit_const_reference<vector>;
    friend class __bit_iterator<vector, false>;
    friend class __bit_iterator<vector, true>;
    friend class __bit_array<vector>;
    friend struct _LIBCPP_VISIBLE hash<vector>;
};

template <class _Allocator>
#ifndef _LIBCPP_DEBUG
_LIBCPP_INLINE_VISIBILITY inline
#endif
void
vector<bool, _Allocator>::__invalidate_all_iterators()
{
#ifdef _LIBCPP_DEBUG
    iterator::__remove_all(this);
    const_iterator::__remove_all(this);
#endif  // _LIBCPP_DEBUG
}

//  Allocate space for __n objects
//  throws length_error if __n > max_size()
//  throws (probably bad_alloc) if memory run out
//  Precondition:  __begin_ == __end_ == __cap() == 0
//  Precondition:  __n > 0
//  Postcondition:  capacity() == __n
//  Postcondition:  size() == 0
template <class _Allocator>
void
vector<bool, _Allocator>::allocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    __n = __external_cap_to_internal(__n);
    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
    this->__size_ = 0;
    this->__cap() = __n;
}

template <class _Allocator>
void
vector<bool, _Allocator>::deallocate()
{
    if (this->__begin_ != 0)
    {
        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
        __invalidate_all_iterators();
        this->__begin_ = 0;
        this->__size_ = this->__cap() = 0;
    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const
{
    size_type __amax = __storage_traits::max_size(__alloc());
    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always
    if (__nmax / __bits_per_word <= __amax)
        return __nmax;
    return __internal_cap_to_external(__amax);
}

//  Precondition:  __new_size > capacity()
template <class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return _STD::max(2*__cap, __align(__new_size));
}

//  Default constructs __n objects starting at __end_
//  Precondition:  __n > 0
//  Precondition:  size() + __n <= capacity()
//  Postcondition:  size() == size() + __n
template <class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)
{
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    _STD::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __old_size = this->__size_;
    this->__size_ += _STD::distance(__first, __last);
    _STD::copy(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<bool, _Allocator>::vector()
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0)
{
}

template <class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<bool, _Allocator>::vector(const allocator_type& __a)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0)
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, false);
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0)
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,
       typename enable_if<__is_input_iterator  <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0)
{
#ifndef _LIBCPP_NO_EXCEPTIONS
    try
    {
#endif  // _LIBCPP_NO_EXCEPTIONS
        for (; __first != __last; ++__first)
            push_back(*__first);
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
    catch (...)
    {
        if (__begin_ != 0)
            __storage_traits::deallocate(__alloc(), __begin_, __cap());
        __invalidate_all_iterators();
        throw;
    }
#endif  // _LIBCPP_NO_EXCEPTIONS
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_input_iterator  <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
#ifndef _LIBCPP_NO_EXCEPTIONS
    try
    {
#endif  // _LIBCPP_NO_EXCEPTIONS
        for (; __first != __last; ++__first)
            push_back(*__first);
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
    catch (...)
    {
        if (__begin_ != 0)
            __storage_traits::deallocate(__alloc(), __begin_, __cap());
        __invalidate_all_iterators();
        throw;
    }
#endif  // _LIBCPP_NO_EXCEPTIONS
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0)
{
    size_type __n = static_cast<size_type>(_STD::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(_STD::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0)
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::~vector()
{
    if (__begin_ != 0)
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
#ifdef _LIBCPP_DEBUG
    __invalidate_all_iterators();
#endif
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))
{
    if (__v.size() > 0)
    {
        allocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__v.size() > 0)
    {
        allocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(const vector& __v)
{
    if (this != &__v)
    {
        __copy_assign_alloc(__v);
        if (__v.__size_)
        {
            if (__v.__size_ > capacity())
            {
                deallocate();
                allocate(__v.__size_);
            }
            _STD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
        }
        __size_ = __v.__size_;
    }
    return *this;
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<bool, _Allocator>::vector(vector&& __v)
    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(__v.__cap_alloc_)
{
    __v.__begin_ = 0;
    __v.__size_ = 0;
    __v.__cap() = 0;
}

template <class _Allocator>
vector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)
    : __begin_(0),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__a == allocator_type(__v.__alloc()))
    {
        this->__begin_ = __v.__begin_;
        this->__size_ = __v.__size_;
        this->__cap() = __v.__cap();
        __v.__begin_ = nullptr;
        __v.__cap() = __v.__size_ = 0;
    }
    else if (__v.size() > 0)
    {
        allocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(vector&& __v)
{
    __move_assign(__v, integral_constant<bool,
          __storage_traits::propagate_on_container_move_assignment::value>());
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, false_type)
{
    if (__alloc() != __c.__alloc())
        assign(__c.begin(), __c.end());
    else
        __move_assign(__c, true_type());
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, true_type)
{
    deallocate();
    this->__begin_ = __c.__begin_;
    this->__size_ = __c.__size_;
    this->__cap() = __c.__cap();
    __move_assign_alloc(__c);
    __c.__begin_ = nullptr;
    __c.__cap() = __c.__size_ = 0;
}

#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Allocator>
void
vector<bool, _Allocator>::assign(size_type __n, const value_type& __x)
{
    __size_ = 0;
    if (__n > 0)
    {
        size_type __c = capacity();
        if (__n <= __c)
            __size_ = __n;
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__n));
            __v.__size_ = __n;
            swap(__v);
        }
        _STD::fill_n(begin(), __n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_forward_iterator<_InputIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    clear();
    difference_type __n = _STD::distance(__first, __last);
    if (__n)
    {
        if (__n > capacity())
        {
            deallocate();
            allocate(__n);
        }
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        vector __v(this->__alloc());
        __v.allocate(__n);
        __v.__construct_at_end(this->begin(), this->end());
        swap(__v);
        __invalidate_all_iterators();
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::shrink_to_fit()
{
    if (__external_cap_to_internal(size()) > __cap())
    {
#ifndef _LIBCPP_NO_EXCEPTIONS
        try
        {
#endif  // _LIBCPP_NO_EXCEPTIONS
            vector(*this, allocator_type(__alloc())).swap(*this);
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
        catch (...)
        {
        }
#endif  // _LIBCPP_NO_EXCEPTIONS
    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
void
vector<bool, _Allocator>::push_back(const value_type& __x)
{
    if (this->__size_ == this->capacity())
        reserve(__recommend(this->__size_ + 1));
    ++this->__size_;
    back() = __x;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)
{
    iterator __r;
    if (size() < capacity())
    {
        const_iterator __old_end = end();
        ++__size_;
        _STD::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + 1));
        __v.__size_ = __size_ + 1;
        __r = _STD::copy(cbegin(), __position, __v.begin());
        _STD::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    *__r = __x;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)
{
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        _STD::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = _STD::copy(cbegin(), __position, __v.begin());
        _STD::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    _STD::fill_n(__r, __n, __x);
    return __r;
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator  <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
    difference_type __off = __position - begin();
    iterator __p = __const_iterator_cast(__position);
    iterator __old_end = end();
    for (; size() != capacity() && __first != __last; ++__first)
    {
        ++this->__size_;
        back() = *__first;
    }
    vector __v(__alloc());
    if (__first != __last)
    {
#ifndef _LIBCPP_NO_EXCEPTIONS
        try
        {
#endif  // _LIBCPP_NO_EXCEPTIONS
            __v.assign(__first, __last);
            difference_type __old_size = static_cast<difference_type>(__old_end - begin());
            difference_type __old_p = __p - begin();
            reserve(__recommend(size() + __v.size()));
            __p = begin() + __old_p;
            __old_end = begin() + __old_size;
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
        catch (...)
        {
            erase(__old_end, end());
            throw;
        }
#endif  // _LIBCPP_NO_EXCEPTIONS
    }
    __p = _STD::rotate(__p, __old_end, end());
    insert(__p, __v.begin(), __v.end());
    return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
    difference_type __n = _STD::distance(__first, __last);
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        _STD::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = _STD::copy(cbegin(), __position, __v.begin());
        _STD::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    _STD::copy(__first, __last, __r);
    return __r;
}

template <class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position)
{
    iterator __r = __const_iterator_cast(__position);
    _STD::copy(__position + 1, this->cend(), __r);
    --__size_;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    iterator __r = __const_iterator_cast(__first);
    difference_type __d = __last - __first;
    _STD::copy(__last, this->cend(), __r);
    __size_ -= __d;
    return __r;
}

template <class _Allocator>
void
vector<bool, _Allocator>::swap(vector& __x)
{
    _STD::swap(this->__begin_, __x.__begin_);
    _STD::swap(this->__size_, __x.__size_);
    _STD::swap(this->__cap(), __x.__cap());
    __swap_alloc(this->__alloc(), __x.__alloc());
#ifdef _LIBCPP_DEBUG
    iterator::swap(this, &__x);
    const_iterator::swap(this, &__x);
#endif  // _LIBCPP_DEBUG
}

template <class _Allocator>
void
vector<bool, _Allocator>::resize(size_type __sz, value_type __x)
{
    size_type __cs = size();
    if (__cs < __sz)
    {
        iterator __r;
        size_type __c = capacity();
        size_type __n = __sz - __cs;
        if (__n <= __c && __cs <= __c - __n)
        {
            __r = end();
            __size_ += __n;
        }
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__size_ + __n));
            __v.__size_ = __size_ + __n;
            __r = _STD::copy(cbegin(), cend(), __v.begin());
            swap(__v);
        }
        _STD::fill_n(__r, __n, __x);
    }
    else
        __size_ = __sz;
}

template <class _Allocator>
void
vector<bool, _Allocator>::flip()
{
    // do middle whole words
    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <class _Allocator>
bool
vector<bool, _Allocator>::__invariants() const
{
    if (this->__begin_ == 0)
    {
        if (this->__size_ != 0 || this->__cap() != 0)
            return false;
    }
    else
    {
        if (this->__cap() == 0)
            return false;
        if (this->__size_ > this->capacity())
            return false;
    }
    return true;
}

template <class _Allocator>
size_t
vector<bool, _Allocator>::__hash_code() const
{
    size_t __h = 0;
    // do middle whole words
    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        __h ^= *__p;
    // do last partial word
    if (__n > 0)
    {
        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __h ^= *__p & __m;
    }
    return __h;
}

template <class _Allocator>
struct _LIBCPP_VISIBLE hash<vector<bool, _Allocator> >
    : public unary_function<vector<bool, _Allocator>, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(const vector<bool, _Allocator>& __vec) const
        {return __vec.__hash_code();}
};

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
bool
operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && _STD::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
bool
operator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
bool
operator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return _STD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
bool
operator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
bool
operator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
bool
operator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
_LIBCPP_INLINE_VISIBILITY inline
void
swap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)
{
    __x.swap(__y);
}

_LIBCPP_END_NAMESPACE_STD

#endif  // _LIBCPP_VECTOR

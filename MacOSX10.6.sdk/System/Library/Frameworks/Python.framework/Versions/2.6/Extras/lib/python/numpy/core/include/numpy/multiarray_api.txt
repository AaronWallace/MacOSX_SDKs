
===========
Numpy C-API
===========
::

  unsigned int
  PyArray_GetNDArrayCVersion(void )


Included at the very first so not auto-grabbed and thus not labeled.

::

  int
  PyArray_SetNumericOps(PyObject *dict)

Set internal structure with number functions that all arrays will use

::

  PyObject *
  PyArray_GetNumericOps(void )

Get dictionary showing number functions that all arrays will use

::

  int
  PyArray_INCREF(PyArrayObject *mp)

For object arrays, increment all internal references.

::

  int
  PyArray_XDECREF(PyArrayObject *mp)

Decrement all internal references for object arrays.
(or arrays with object fields)

::

  void
  PyArray_SetStringFunction(PyObject *op, int repr)

Set the array print function to be a Python function.

::

  PyArray_Descr *
  PyArray_DescrFromType(int type)

Get the PyArray_Descr structure for a type.

::

  PyObject *
  PyArray_TypeObjectFromType(int type)

Get a typeobject from a type-number -- can return NULL.

New reference

::

  char *
  PyArray_Zero(PyArrayObject *arr)

Get pointer to zero of correct type for array.

::

  char *
  PyArray_One(PyArrayObject *arr)

Get pointer to one of correct type for array

::

  PyObject *
  PyArray_CastToType(PyArrayObject *mp, PyArray_Descr *at, int fortran)

For backward compatibility

Cast an array using typecode structure.
steals reference to at --- cannot be NULL

::

  int
  PyArray_CastTo(PyArrayObject *out, PyArrayObject *mp)

Cast to an already created array.

::

  int
  PyArray_CastAnyTo(PyArrayObject *out, PyArrayObject *mp)

Cast to an already created array.  Arrays don't have to be "broadcastable"
Only requirement is they have the same number of elements.

::

  int
  PyArray_CanCastSafely(int fromtype, int totype)

Check the type coercion rules.

::

  npy_bool
  PyArray_CanCastTo(PyArray_Descr *from, PyArray_Descr *to)

leaves reference count alone --- cannot be NULL

::

  int
  PyArray_ObjectType(PyObject *op, int minimum_type)

Return the typecode of the array a Python object would be converted to

::

  PyArray_Descr *
  PyArray_DescrFromObject(PyObject *op, PyArray_Descr *mintype)

new reference -- accepts NULL for mintype

::

  PyArrayObject **
  PyArray_ConvertToCommonType(PyObject *op, int *retn)


::

  PyArray_Descr *
  PyArray_DescrFromScalar(PyObject *sc)

Return descr object from array scalar.

New reference

::

  PyArray_Descr *
  PyArray_DescrFromTypeObject(PyObject *type)


::

  npy_intp
  PyArray_Size(PyObject *op)

Compute the size of an array (in number of items)

::

  PyObject *
  PyArray_Scalar(void *data, PyArray_Descr *descr, PyObject *base)

Get scalar-equivalent to a region of memory described by a descriptor.

::

  PyObject *
  PyArray_FromScalar(PyObject *scalar, PyArray_Descr *outcode)

Get 0-dim array from scalar

0-dim array from array-scalar object
always contains a copy of the data
unless outcode is NULL, it is of void type and the referrer does
not own it either.

steals reference to outcode

::

  void
  PyArray_ScalarAsCtype(PyObject *scalar, void *ctypeptr)

Convert to c-type

no error checking is performed -- ctypeptr must be same type as scalar
in case of flexible type, the data is not copied
into ctypeptr which is expected to be a pointer to pointer

::

  int
  PyArray_CastScalarToCtype(PyObject *scalar, void
                            *ctypeptr, PyArray_Descr *outcode)

Cast Scalar to c-type

The output buffer must be large-enough to receive the value
Even for flexible types which is different from ScalarAsCtype
where only a reference for flexible types is returned

This may not work right on narrow builds for NumPy unicode scalars.

::

  int
  PyArray_CastScalarDirect(PyObject *scalar, PyArray_Descr
                           *indescr, void *ctypeptr, int outtype)

Cast Scalar to c-type

::

  PyObject *
  PyArray_ScalarFromObject(PyObject *object)

Get an Array Scalar From a Python Object

Returns NULL if unsuccessful but error is only set if another error occurred.
Currently only Numeric-like object supported.

::

  PyArray_VectorUnaryFunc *
  PyArray_GetCastFunc(PyArray_Descr *descr, int type_num)

Get a cast function to cast from the input descriptor to the
output type_number (must be a registered data-type).
Returns NULL if un-successful.

::

  PyObject *
  PyArray_FromDims(int nd, int *d, int type)

Construct an empty array from dimensions and typenum

::

  PyObject *
  PyArray_FromDimsAndDataAndDescr(int nd, int *d, PyArray_Descr
                                  *descr, char *data)

Like FromDimsAndData but uses the Descr structure instead of typecode
as input.

::

  PyObject *
  PyArray_FromAny(PyObject *op, PyArray_Descr *newtype, int
                  min_depth, int max_depth, int flags, PyObject
                  *context)

Does not check for ENSURECOPY and NOTSWAPPED in flags
Steals a reference to newtype --- which can be NULL

::

  PyObject *
  PyArray_EnsureArray(PyObject *op)

This is a quick wrapper around PyArray_FromAny(op, NULL, 0, 0, ENSUREARRAY)
that special cases Arrays and PyArray_Scalars up front
It *steals a reference* to the object
It also guarantees that the result is PyArray_Type
Because it decrefs op if any conversion needs to take place
so it can be used like PyArray_EnsureArray(some_function(...))

::

  PyObject *
  PyArray_EnsureAnyArray(PyObject *op)


::

  PyObject *
  PyArray_FromFile(FILE *fp, PyArray_Descr *dtype, intp num, char *sep)


Given a ``FILE *`` pointer ``fp``, and a ``PyArray_Descr``, return an
array corresponding to the data encoded in that file.

If the dtype is NULL, the default array type is used (double).
If non-null, the reference is stolen.

The number of elements to read is given as ``num``; if it is < 0, then
then as many as possible are read.

If ``sep`` is NULL or empty, then binary data is assumed, else
text data, with ``sep`` as the separator between elements. Whitespace in
the separator matches any length of whitespace in the text, and a match
for whitespace around the separator is added.

For memory-mapped files, use the buffer interface. No more data than
necessary is read by this routine.

::

  PyObject *
  PyArray_FromString(char *data, intp slen, PyArray_Descr *dtype, intp
                     num, char *sep)


Given a pointer to a string ``data``, a string length ``slen``, and
a ``PyArray_Descr``, return an array corresponding to the data
encoded in that string.

If the dtype is NULL, the default array type is used (double).
If non-null, the reference is stolen.

If ``slen`` is < 0, then the end of string is used for text data.
It is an error for ``slen`` to be < 0 for binary data (since embedded NULLs
would be the norm).

The number of elements to read is given as ``num``; if it is < 0, then
then as many as possible are read.

If ``sep`` is NULL or empty, then binary data is assumed, else
text data, with ``sep`` as the separator between elements. Whitespace in
the separator matches any length of whitespace in the text, and a match
for whitespace around the separator is added.

::

  PyObject *
  PyArray_FromBuffer(PyObject *buf, PyArray_Descr *type, intp
                     count, intp offset)


::

  PyObject *
  PyArray_FromIter(PyObject *obj, PyArray_Descr *dtype, intp count)


steals a reference to dtype (which cannot be NULL)

::

  PyObject *
  PyArray_Return(PyArrayObject *mp)


Return either an array or the appropriate Python object if the array
is 0d and matches a Python type.

::

  PyObject *
  PyArray_GetField(PyArrayObject *self, PyArray_Descr *typed, int
                   offset)

Get a subset of bytes from each element of the array

::

  int
  PyArray_SetField(PyArrayObject *self, PyArray_Descr *dtype, int
                   offset, PyObject *val)

Set a subset of bytes from each element of the array

::

  PyObject *
  PyArray_Byteswap(PyArrayObject *self, Bool inplace)


::

  PyObject *
  PyArray_Resize(PyArrayObject *self, PyArray_Dims *newshape, int
                 refcheck, NPY_ORDER fortran)

Resize (reallocate data).  Only works if nothing else is referencing this
array and it is contiguous.  If refcheck is 0, then the reference count is
not checked and assumed to be 1.  You still must own this data and have no
weak-references and no base object.

::

  int
  PyArray_MoveInto(PyArrayObject *dest, PyArrayObject *src)

Move the memory of one array into another.

::

  int
  PyArray_CopyInto(PyArrayObject *dest, PyArrayObject *src)

Copy an Array into another array -- memory must not overlap.

::

  int
  PyArray_CopyAnyInto(PyArrayObject *dest, PyArrayObject *src)

Copy an Array into another array -- memory must not overlap
Does not require src and dest to have "broadcastable" shapes
(only the same number of elements).

::

  int
  PyArray_CopyObject(PyArrayObject *dest, PyObject *src_object)


::

  PyObject *
  PyArray_NewCopy(PyArrayObject *m1, NPY_ORDER fortran)

Copy an array.

::

  PyObject *
  PyArray_ToList(PyArrayObject *self)

To List

::

  PyObject *
  PyArray_ToString(PyArrayObject *self, NPY_ORDER order)


::

  int
  PyArray_ToFile(PyArrayObject *self, FILE *fp, char *sep, char *format)

To File

::

  int
  PyArray_Dump(PyObject *self, PyObject *file, int protocol)


::

  PyObject *
  PyArray_Dumps(PyObject *self, int protocol)


::

  int
  PyArray_ValidType(int type)

Is the typenum valid?

::

  void
  PyArray_UpdateFlags(PyArrayObject *ret, int flagmask)

Update Several Flags at once.

::

  PyObject *
  PyArray_New(PyTypeObject *subtype, int nd, intp *dims, int
              type_num, intp *strides, void *data, int itemsize, int
              flags, PyObject *obj)

Generic new array creation routine.

::

  PyObject *
  PyArray_NewFromDescr(PyTypeObject *subtype, PyArray_Descr *descr, int
                       nd, intp *dims, intp *strides, void *data, int
                       flags, PyObject *obj)

Generic new array creation routine.

steals a reference to descr (even on failure)

::

  PyArray_Descr *
  PyArray_DescrNew(PyArray_Descr *base)

base cannot be NULL

::

  PyArray_Descr *
  PyArray_DescrNewFromType(int type_num)


::

  double
  PyArray_GetPriority(PyObject *obj, double default_)

Get Priority from object

::

  PyObject *
  PyArray_IterNew(PyObject *obj)

Get Iterator.

::

  PyObject *
  PyArray_MultiIterNew(int n, ... )

Get MultiIterator,

::

  int
  PyArray_PyIntAsInt(PyObject *o)


::

  npy_intp
  PyArray_PyIntAsIntp(PyObject *o)


::

  int
  PyArray_Broadcast(PyArrayMultiIterObject *mit)


::

  void
  PyArray_FillObjectArray(PyArrayObject *arr, PyObject *obj)

Assumes contiguous

::

  int
  PyArray_FillWithScalar(PyArrayObject *arr, PyObject *obj)


::

  npy_bool
  PyArray_CheckStrides(int elsize, int nd, intp numbytes, intp
                       offset, intp *dims, intp *newstrides)


::

  PyArray_Descr *
  PyArray_DescrNewByteorder(PyArray_Descr *self, char newendian)


returns a copy of the PyArray_Descr structure with the byteorder
altered:
no arguments:  The byteorder is swapped (in all subfields as well)
single argument:  The byteorder is forced to the given state
(in all subfields as well)

Valid states:  ('big', '>') or ('little' or '<')
('native', or '=')

If a descr structure with | is encountered it's own
byte-order is not changed but any fields are:


Deep bytorder change of a data-type descriptor
Leaves reference count of self unchanged --- does not DECREF self ***

::

  PyObject *
  PyArray_IterAllButAxis(PyObject *obj, int *inaxis)

Get Iterator that iterates over all but one axis (don't use this with
PyArray_ITER_GOTO1D).  The axis will be over-written if negative
with the axis having the smallest stride.

::

  PyObject *
  PyArray_CheckFromAny(PyObject *op, PyArray_Descr *descr, int
                       min_depth, int max_depth, int requires, PyObject
                       *context)

steals a reference to descr -- accepts NULL

::

  PyObject *
  PyArray_FromArray(PyArrayObject *arr, PyArray_Descr *newtype, int
                    flags)

steals reference to newtype --- acc. NULL

::

  PyObject *
  PyArray_FromInterface(PyObject *input)


::

  PyObject *
  PyArray_FromStructInterface(PyObject *input)


::

  PyObject *
  PyArray_FromArrayAttr(PyObject *op, PyArray_Descr *typecode, PyObject
                        *context)


::

  NPY_SCALARKIND
  PyArray_ScalarKind(int typenum, PyArrayObject **arr)

ScalarKind

::

  int
  PyArray_CanCoerceScalar(int thistype, int neededtype, NPY_SCALARKIND
                          scalar)


::

  PyObject *
  PyArray_NewFlagsObject(PyObject *obj)


Get New ArrayFlagsObject

::

  npy_bool
  PyArray_CanCastScalar(PyTypeObject *from, PyTypeObject *to)

See if array scalars can be cast.

::

  int
  PyArray_CompareUCS4(npy_ucs4 *s1, npy_ucs4 *s2, size_t len)


::

  int
  PyArray_RemoveSmallest(PyArrayMultiIterObject *multi)

Adjusts previously broadcasted iterators so that the axis with
the smallest sum of iterator strides is not iterated over.
Returns dimension which is smallest in the range [0,multi->nd).
A -1 is returned if multi->nd == 0.

don't use with PyArray_ITER_GOTO1D because factors are not adjusted

::

  int
  PyArray_ElementStrides(PyObject *arr)


::

  void
  PyArray_Item_INCREF(char *data, PyArray_Descr *descr)


::

  void
  PyArray_Item_XDECREF(char *data, PyArray_Descr *descr)


::

  PyObject *
  PyArray_FieldNames(PyObject *fields)

Return the tuple of ordered field names from a dictionary.

::

  PyObject *
  PyArray_Transpose(PyArrayObject *ap, PyArray_Dims *permute)

Return Transpose.

::

  PyObject *
  PyArray_TakeFrom(PyArrayObject *self0, PyObject *indices0, int
                   axis, PyArrayObject *ret, NPY_CLIPMODE clipmode)

Take

::

  PyObject *
  PyArray_PutTo(PyArrayObject *self, PyObject*values0, PyObject
                *indices0, NPY_CLIPMODE clipmode)

Put values into an array

::

  PyObject *
  PyArray_PutMask(PyArrayObject *self, PyObject*values0, PyObject*mask0)

Put values into an array according to a mask.

::

  PyObject *
  PyArray_Repeat(PyArrayObject *aop, PyObject *op, int axis)

Repeat the array.

::

  PyObject *
  PyArray_Choose(PyArrayObject *ip, PyObject *op, PyArrayObject
                 *ret, NPY_CLIPMODE clipmode)


::

  int
  PyArray_Sort(PyArrayObject *op, int axis, NPY_SORTKIND which)

Sort an array in-place

::

  PyObject *
  PyArray_ArgSort(PyArrayObject *op, int axis, NPY_SORTKIND which)

ArgSort an array

::

  PyObject *
  PyArray_SearchSorted(PyArrayObject *op1, PyObject *op2, NPY_SEARCHSIDE
                       side)

Numeric.searchsorted(a,v)

::

  PyObject *
  PyArray_ArgMax(PyArrayObject *op, int axis, PyArrayObject *out)

ArgMax

::

  PyObject *
  PyArray_ArgMin(PyArrayObject *ap, int axis, PyArrayObject *out)

ArgMin

::

  PyObject *
  PyArray_Reshape(PyArrayObject *self, PyObject *shape)

Reshape

::

  PyObject *
  PyArray_Newshape(PyArrayObject *self, PyArray_Dims *newdims, NPY_ORDER
                   fortran)

New shape for an array

::

  PyObject *
  PyArray_Squeeze(PyArrayObject *self)


return a new view of the array object with all of its unit-length
dimensions squeezed out if needed, otherwise
return the same array.

::

  PyObject *
  PyArray_View(PyArrayObject *self, PyArray_Descr *type, PyTypeObject
               *pytype)

View
steals a reference to type -- accepts NULL

::

  PyObject *
  PyArray_SwapAxes(PyArrayObject *ap, int a1, int a2)

SwapAxes

::

  PyObject *
  PyArray_Max(PyArrayObject *ap, int axis, PyArrayObject *out)

Max

::

  PyObject *
  PyArray_Min(PyArrayObject *ap, int axis, PyArrayObject *out)

Min

::

  PyObject *
  PyArray_Ptp(PyArrayObject *ap, int axis, PyArrayObject *out)

Ptp

::

  PyObject *
  PyArray_Mean(PyArrayObject *self, int axis, int rtype, PyArrayObject
               *out)

Mean

::

  PyObject *
  PyArray_Trace(PyArrayObject *self, int offset, int axis1, int
                axis2, int rtype, PyArrayObject *out)

Trace

::

  PyObject *
  PyArray_Diagonal(PyArrayObject *self, int offset, int axis1, int
                   axis2)

Diagonal

::

  PyObject *
  PyArray_Clip(PyArrayObject *self, PyObject *min, PyObject
               *max, PyArrayObject *out)

Clip

::

  PyObject *
  PyArray_Conjugate(PyArrayObject *self, PyArrayObject *out)

Conjugate

::

  PyObject *
  PyArray_Nonzero(PyArrayObject *self)

Nonzero

::

  PyObject *
  PyArray_Std(PyArrayObject *self, int axis, int rtype, PyArrayObject
              *out, int variance)

Set variance to 1 to by-pass square-root calculation and return variance
Std

::

  PyObject *
  PyArray_Sum(PyArrayObject *self, int axis, int rtype, PyArrayObject
              *out)

Sum

::

  PyObject *
  PyArray_CumSum(PyArrayObject *self, int axis, int rtype, PyArrayObject
                 *out)

CumSum

::

  PyObject *
  PyArray_Prod(PyArrayObject *self, int axis, int rtype, PyArrayObject
               *out)

Prod

::

  PyObject *
  PyArray_CumProd(PyArrayObject *self, int axis, int
                  rtype, PyArrayObject *out)

CumProd

::

  PyObject *
  PyArray_All(PyArrayObject *self, int axis, PyArrayObject *out)

All

::

  PyObject *
  PyArray_Any(PyArrayObject *self, int axis, PyArrayObject *out)

Any

::

  PyObject *
  PyArray_Compress(PyArrayObject *self, PyObject *condition, int
                   axis, PyArrayObject *out)

Compress

::

  PyObject *
  PyArray_Flatten(PyArrayObject *a, NPY_ORDER order)

Flatten

::

  PyObject *
  PyArray_Ravel(PyArrayObject *a, NPY_ORDER fortran)

Ravel
Returns a contiguous array

::

  npy_intp
  PyArray_MultiplyList(intp *l1, int n)

Multiply a List

::

  int
  PyArray_MultiplyIntList(int *l1, int n)

Multiply a List of ints

::

  void *
  PyArray_GetPtr(PyArrayObject *obj, intp*ind)

Produce a pointer into array

::

  int
  PyArray_CompareLists(intp *l1, intp *l2, int n)

Compare Lists

::

  int
  PyArray_AsCArray(PyObject **op, void *ptr, intp *dims, int
                   nd, PyArray_Descr*typedescr)

Simulate a C-array
steals a reference to typedescr -- can be NULL

::

  int
  PyArray_As1D(PyObject **op, char **ptr, int *d1, int typecode)

Convert to a 1D C-array

::

  int
  PyArray_As2D(PyObject **op, char ***ptr, int *d1, int *d2, int
               typecode)

Convert to a 2D C-array

::

  int
  PyArray_Free(PyObject *op, void *ptr)

Free pointers created if As2D is called

::

  int
  PyArray_Converter(PyObject *object, PyObject **address)


Useful to pass as converter function for O& processing in PyArgs_ParseTuple.

This conversion function can be used with the "O&" argument for
PyArg_ParseTuple.  It will immediately return an object of array type
or will convert to a CARRAY any other object.

If you use PyArray_Converter, you must DECREF the array when finished
as you get a new reference to it.

::

  int
  PyArray_IntpFromSequence(PyObject *seq, intp *vals, int maxvals)

PyArray_IntpFromSequence
Returns the number of dimensions or -1 if an error occurred.
vals must be large enough to hold maxvals

::

  PyObject *
  PyArray_Concatenate(PyObject *op, int axis)

Concatenate

Concatenate an arbitrary Python sequence into an array.
op is a python object supporting the sequence interface.
Its elements will be concatenated together to form a single
multidimensional array. If axis is MAX_DIMS or bigger, then
each sequence object will be flattened before concatenation

::

  PyObject *
  PyArray_InnerProduct(PyObject *op1, PyObject *op2)

Numeric.innerproduct(a,v)

::

  PyObject *
  PyArray_MatrixProduct(PyObject *op1, PyObject *op2)

Numeric.matrixproduct(a,v)
just like inner product but does the swapaxes stuff on the fly

::

  PyObject *
  PyArray_CopyAndTranspose(PyObject *op)

Fast Copy and Transpose

::

  PyObject *
  PyArray_Correlate(PyObject *op1, PyObject *op2, int mode)

Numeric.correlate(a1,a2,mode)

::

  int
  PyArray_TypestrConvert(int itemsize, int gentype)

Typestr converter

::

  int
  PyArray_DescrConverter(PyObject *obj, PyArray_Descr **at)

Get typenum from an object -- None goes to PyArray_DEFAULT
This function takes a Python object representing a type and converts it
to a the correct PyArray_Descr * structure to describe the type.

Many objects can be used to represent a data-type which in NumPy is
quite a flexible concept.

This is the central code that converts Python objects to
Type-descriptor objects that are used throughout numpy.
new reference in *at

::

  int
  PyArray_DescrConverter2(PyObject *obj, PyArray_Descr **at)

Get typenum from an object -- None goes to NULL

::

  int
  PyArray_IntpConverter(PyObject *obj, PyArray_Dims *seq)

Get intp chunk from sequence

This function takes a Python sequence object and allocates and
fills in an intp array with the converted values.

Remember to free the pointer seq.ptr when done using
PyDimMem_FREE(seq.ptr)**

::

  int
  PyArray_BufferConverter(PyObject *obj, PyArray_Chunk *buf)

Get buffer chunk from object

this function takes a Python object which exposes the (single-segment)
buffer interface and returns a pointer to the data segment

You should increment the reference count by one of buf->base
if you will hang on to a reference

You only get a borrowed reference to the object. Do not free the
memory...

::

  int
  PyArray_AxisConverter(PyObject *obj, int *axis)

Get axis from an object (possibly None) -- a converter function,

::

  int
  PyArray_BoolConverter(PyObject *object, Bool *val)

Convert an object to true / false

::

  int
  PyArray_ByteorderConverter(PyObject *obj, char *endian)

Convert object to endian

::

  int
  PyArray_OrderConverter(PyObject *object, NPY_ORDER *val)

Convert an object to FORTRAN / C / ANY

::

  unsigned char
  PyArray_EquivTypes(PyArray_Descr *typ1, PyArray_Descr *typ2)


This function returns true if the two typecodes are
equivalent (same basic kind and same itemsize).

::

  PyObject *
  PyArray_Zeros(int nd, intp *dims, PyArray_Descr *type, int fortran)

Zeros

steal a reference
accepts NULL type

::

  PyObject *
  PyArray_Empty(int nd, intp *dims, PyArray_Descr *type, int fortran)

Empty

accepts NULL type
steals referenct to type

::

  PyObject *
  PyArray_Where(PyObject *condition, PyObject *x, PyObject *y)

Where

::

  PyObject *
  PyArray_Arange(double start, double stop, double step, int type_num)

Arange,

::

  PyObject *
  PyArray_ArangeObj(PyObject *start, PyObject *stop, PyObject
                    *step, PyArray_Descr *dtype)


ArangeObj,

this doesn't change the references

::

  int
  PyArray_SortkindConverter(PyObject *obj, NPY_SORTKIND *sortkind)

Convert object to sort kind

::

  PyObject *
  PyArray_LexSort(PyObject *sort_keys, int axis)

LexSort an array providing indices that will sort a collection of arrays
lexicographically.  The first key is sorted on first, followed by the second key
-- requires that arg"merge"sort is available for each sort_key

Returns an index array that shows the indexes for the lexicographic sort along
the given axis.

::

  PyObject *
  PyArray_Round(PyArrayObject *a, int decimals, PyArrayObject *out)

Round

::

  unsigned char
  PyArray_EquivTypenums(int typenum1, int typenum2)


::

  int
  PyArray_RegisterDataType(PyArray_Descr *descr)

Register Data type
Does not change the reference count of descr

::

  int
  PyArray_RegisterCastFunc(PyArray_Descr *descr, int
                           totype, PyArray_VectorUnaryFunc *castfunc)

Register Casting Function
Replaces any function currently stored.

::

  int
  PyArray_RegisterCanCast(PyArray_Descr *descr, int
                          totype, NPY_SCALARKIND scalar)

Register a type number indicating that a descriptor can be cast
to it safely

::

  void
  PyArray_InitArrFuncs(PyArray_ArrFuncs *f)

Initialize arrfuncs to NULL

::

  PyObject *
  PyArray_IntTupleFromIntp(int len, intp *vals)

PyArray_IntTupleFromIntp

::

  int
  PyArray_TypeNumFromName(char *str)


::

  int
  PyArray_ClipmodeConverter(PyObject *object, NPY_CLIPMODE *val)

Convert an object to NPY_RAISE / NPY_CLIP / NPY_WRAP

::

  int
  PyArray_OutputConverter(PyObject *object, PyArrayObject **address)

Useful to pass as converter function for O& processing in
PyArgs_ParseTuple for output arrays

::

  PyObject *
  PyArray_BroadcastToShape(PyObject *obj, intp *dims, int nd)

Get Iterator broadcast to a particular shape

::

  void
  _PyArray_SigintHandler(int signum)


::

  void*
  _PyArray_GetSigintBuf(void )


::

  int
  PyArray_DescrAlignConverter(PyObject *obj, PyArray_Descr **at)


Get type-descriptor from an object forcing alignment if possible
None goes to DEFAULT type.

any object with the .fields attribute and/or .itemsize attribute (if the
.fields attribute does not give the total size -- i.e. a partial record
naming).  If itemsize is given it must be >= size computed from fields

The .fields attribute must return a convertible dictionary if present.
Result inherits from PyArray_VOID.

::

  int
  PyArray_DescrAlignConverter2(PyObject *obj, PyArray_Descr **at)


Get type-descriptor from an object forcing alignment if possible
None goes to NULL.

::

  int
  PyArray_SearchsideConverter(PyObject *obj, void *addr)

Convert object to searchsorted side

::

  PyObject *
  PyArray_CheckAxis(PyArrayObject *arr, int *axis, int flags)

PyArray_CheckAxis

check that axis is valid
convert 0-d arrays to 1-d arrays

::

  npy_intp
  PyArray_OverflowMultiplyList(intp *l1, int n)

Multiply a List of Non-negative numbers with over-flow detection.

::

  int
  PyArray_CompareString(char *s1, char *s2, size_t len)


::

  PyObject *
  PyArray_MultiIterFromObjects(PyObject **mps, int n, int nadd, ... )

Get MultiIterator from array of Python objects and any additional

PyObject **mps -- array of PyObjects
int n - number of PyObjects in the array
int nadd - number of additional arrays to include in the iterator.

Returns a multi-iterator object.

::

  int
  PyArray_GetEndianness(void )


::

  unsigned int
  PyArray_GetNDArrayCFeatureVersion(void )

Returns the built-in (at compilation time) C API version

::

  PyObject *
  PyArray_Correlate2(PyObject *op1, PyObject *op2, int mode)

correlate(a1,a2,mode)

This function computes the usual correlation (correlate(a1, a2) !=
correlate(a2, a1), and conjugate the second argument for complex inputs

::

  PyObject*
  PyArray_NeighborhoodIterNew(PyArrayIterObject *x, intp *bounds, int
                              mode, PyArrayObject*fill)

A Neighborhood Iterator object.


.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "feature 3pm"
.TH feature 3pm "2012-11-03" "perl v5.12.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
feature \- Perl pragma to enable new features
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    use feature qw(switch say);
\&    given ($foo) {
\&        when (1)          { say "\e$foo == 1" }
\&        when ([2,3])      { say "\e$foo == 2 || \e$foo == 3" }
\&        when (/^a[bc]d$/) { say "\e$foo eq \*(Aqabd\*(Aq || \e$foo eq \*(Aqacd\*(Aq" }
\&        when ($_ > 100)   { say "\e$foo > 100" }
\&        default           { say "None of the above" }
\&    }
\&
\&    use feature \*(Aq:5.10\*(Aq; # loads all features available in perl 5.10
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It is usually impossible to add new syntax to Perl without breaking
some existing programs. This pragma provides a way to minimize that
risk. New syntactic constructs, or new semantic meanings to older
constructs, can be enabled by \f(CW\*(C`use feature \*(Aqfoo\*(Aq\*(C'\fR, and will be parsed
only when the appropriate feature pragma is in scope.
.SS "Lexical effect"
.IX Subsection "Lexical effect"
Like other pragmas (\f(CW\*(C`use strict\*(C'\fR, for example), features have a lexical
effect. \f(CW\*(C`use feature qw(foo)\*(C'\fR will only make the feature \*(L"foo\*(R" available
from that point to the end of the enclosing block.
.PP
.Vb 5
\&    {
\&        use feature \*(Aqsay\*(Aq;
\&        say "say is available here";
\&    }
\&    print "But not here.\en";
.Ve
.ie n .SS """no feature"""
.el .SS "\f(CWno feature\fP"
.IX Subsection "no feature"
Features can also be turned off by using \f(CW\*(C`no feature "foo"\*(C'\fR. This too
has lexical effect.
.PP
.Vb 7
\&    use feature \*(Aqsay\*(Aq;
\&    say "say is available here";
\&    {
\&        no feature \*(Aqsay\*(Aq;
\&        print "But not here.\en";
\&    }
\&    say "Yet it is here.";
.Ve
.PP
\&\f(CW\*(C`no feature\*(C'\fR with no features specified will turn off all features.
.SS "The 'switch' feature"
.IX Subsection "The 'switch' feature"
\&\f(CW\*(C`use feature \*(Aqswitch\*(Aq\*(C'\fR tells the compiler to enable the Perl 6
given/when construct.
.PP
See \*(L"Switch statements\*(R" in perlsyn for details.
.SS "The 'say' feature"
.IX Subsection "The 'say' feature"
\&\f(CW\*(C`use feature \*(Aqsay\*(Aq\*(C'\fR tells the compiler to enable the Perl 6
\&\f(CW\*(C`say\*(C'\fR function.
.PP
See \*(L"say\*(R" in perlfunc for details.
.SS "the 'state' feature"
.IX Subsection "the 'state' feature"
\&\f(CW\*(C`use feature \*(Aqstate\*(Aq\*(C'\fR tells the compiler to enable \f(CW\*(C`state\*(C'\fR
variables.
.PP
See \*(L"Persistent Private Variables\*(R" in perlsub for details.
.SS "the 'unicode_strings' feature"
.IX Subsection "the 'unicode_strings' feature"
\&\f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR tells the compiler to treat
all strings outside of \f(CW\*(C`use locale\*(C'\fR and \f(CW\*(C`use bytes\*(C'\fR as Unicode. It is
available starting with Perl 5.11.3.
.PP
See \*(L"The \*(R"Unicode Bug"" in perlunicode for details.
.SH "FEATURE BUNDLES"
.IX Header "FEATURE BUNDLES"
It's possible to load a whole slew of features in one go, using
a \fIfeature bundle\fR. The name of a feature bundle is prefixed with
a colon, to distinguish it from an actual feature. At present, the
only feature bundle is \f(CW\*(C`use feature ":5.10"\*(C'\fR which is equivalent
to \f(CW\*(C`use feature qw(switch say state)\*(C'\fR.
.PP
Specifying sub-versions such as the \f(CW0\fR in \f(CW5.10.0\fR in feature bundles has
no effect: feature bundles are guaranteed to be the same for all sub-versions.
.SH "IMPLICIT LOADING"
.IX Header "IMPLICIT LOADING"
There are two ways to load the \f(CW\*(C`feature\*(C'\fR pragma implicitly :
.IP "\(bu" 4
By using the \f(CW\*(C`\-E\*(C'\fR switch on the command-line instead of \f(CW\*(C`\-e\*(C'\fR. It enables
all available features in the main compilation unit (that is, the one-liner.)
.IP "\(bu" 4
By requiring explicitly a minimal Perl version number for your program, with
the \f(CW\*(C`use VERSION\*(C'\fR construct, and when the version is higher than or equal to
5.10.0. That is,
.Sp
.Vb 1
\&    use 5.10.0;
.Ve
.Sp
will do an implicit
.Sp
.Vb 1
\&    use feature \*(Aq:5.10\*(Aq;
.Ve
.Sp
and so on. Note how the trailing sub-version is automatically stripped from the
version.
.Sp
But to avoid portability warnings (see \*(L"use\*(R" in perlfunc), you may prefer:
.Sp
.Vb 1
\&    use 5.010;
.Ve
.Sp
with the same effect.

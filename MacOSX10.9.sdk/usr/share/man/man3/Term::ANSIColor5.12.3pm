.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ANSIColor 3pm"
.TH Term::ANSIColor 3pm "2012-11-03" "perl v5.12.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ANSIColor \- Color screen output using ANSI escape sequences
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&    use Term::ANSIColor;
\&    print color \*(Aqbold blue\*(Aq;
\&    print "This text is bold blue.\en";
\&    print color \*(Aqreset\*(Aq;
\&    print "This text is normal.\en";
\&    print colored ("Yellow on magenta.", \*(Aqyellow on_magenta\*(Aq), "\en";
\&    print "This text is normal.\en";
\&    print colored [\*(Aqyellow on_magenta\*(Aq], \*(AqYellow on magenta.\*(Aq;
\&    print "\en";
\&
\&    use Term::ANSIColor qw(uncolor);
\&    print uncolor (\*(Aq01;31\*(Aq), "\en";
\&
\&    use Term::ANSIColor qw(colorstrip);
\&    print colorstrip \*(Aq\ee[1mThis is bold\ee[0m\*(Aq, "\en";
\&
\&    use Term::ANSIColor qw(colorvalid);
\&    my $valid = colorvalid (\*(Aqblue bold\*(Aq, \*(Aqon_magenta\*(Aq);
\&    print "Color string is ", $valid ? "valid\en" : "invalid\en";
\&
\&    use Term::ANSIColor qw(:constants);
\&    print BOLD, BLUE, "This text is in bold blue.\en", RESET;
\&
\&    use Term::ANSIColor qw(:constants);
\&    {
\&        local $Term::ANSIColor::AUTORESET = 1;
\&        print BOLD BLUE "This text is in bold blue.\en";
\&        print "This text is normal.\en";
\&    }
\&
\&    use Term::ANSIColor qw(:pushpop);
\&    print PUSHCOLOR RED ON_GREEN "This text is red on green.\en";
\&    print PUSHCOLOR BLUE "This text is blue on green.\en";
\&    print RESET BLUE "This text is just blue.\en";
\&    print POPCOLOR "Back to red on green.\en";
\&    print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\en";
\&    print "This text is red on green.\en";
\&    {
\&        local $Term::ANSIColor::AUTOLOCAL = 1;
\&        print ON_BLUE "This text is red on blue.\en";
\&        print "This text is red on green.\en";
\&    }
\&    print POPCOLOR "Back to whatever we started as.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has two interfaces, one through \fIcolor()\fR and \fIcolored()\fR and the
other through constants.  It also offers the utility functions \fIuncolor()\fR,
\&\fIcolorstrip()\fR, and \fIcolorvalid()\fR, which have to be explicitly imported to be
used (see \*(L"\s-1SYNOPSIS\s0\*(R").
.SS "Function Interface"
.IX Subsection "Function Interface"
\&\fIcolor()\fR takes any number of strings as arguments and considers them to be
space-separated lists of attributes.  It then forms and returns the escape
sequence to set those attributes.  It doesn't print it out, just returns
it, so you'll have to print it yourself if you want to (this is so that
you can save it as a string, pass it to something else, send it to a file
handle, or do anything else with it that you might care to).  \fIcolor()\fR
throws an exception if given an invalid attribute, so you can also use it
to check attribute names for validity (see \*(L"\s-1EXAMPLES\s0\*(R").
.PP
\&\fIuncolor()\fR performs the opposite translation, turning escape sequences
into a list of strings.
.PP
\&\fIcolorstrip()\fR removes all color escape sequences from the provided strings,
returning the modified strings separately in array context or joined
together in scalar context.  Its arguments are not modified.
.PP
\&\fIcolorvalid()\fR takes attribute strings the same as \fIcolor()\fR and returns true
if all attributes are known and false otherwise.
.PP
The recognized non-color attributes are clear, reset, bold, dark, faint,
underline, underscore, blink, reverse, and concealed.  Clear and reset
(reset to default attributes), dark and faint (dim and saturated), and
underline and underscore are equivalent, so use whichever is the most
intuitive to you.  The recognized foreground color attributes are black,
red, green, yellow, blue, magenta, cyan, and white.  The recognized
background color attributes are on_black, on_red, on_green, on_yellow,
on_blue, on_magenta, on_cyan, and on_white.  Case is not significant.
.PP
Note that not all attributes are supported by all terminal types, and some
terminals may not support any of these sequences.  Dark and faint, blink,
and concealed in particular are frequently not implemented.
.PP
Attributes, once set, last until they are unset (by sending the attribute
\&\f(CW\*(C`clear\*(C'\fR or \f(CW\*(C`reset\*(C'\fR).  Be careful to do this, or otherwise your attribute
will last after your script is done running, and people get very annoyed
at having their prompt and typing changed to weird colors.
.PP
As an aid to help with this, \fIcolored()\fR takes a scalar as the first
argument and any number of attribute strings as the second argument and
returns the scalar wrapped in escape codes so that the attributes will be
set as requested before the string and reset to normal after the string.
Alternately, you can pass a reference to an array as the first argument,
and then the contents of that array will be taken as attributes and color
codes and the remainder of the arguments as text to colorize.
.PP
Normally, \fIcolored()\fR just puts attribute codes at the beginning and end of
the string, but if you set \f(CW$Term::ANSIColor::EACHLINE\fR to some string, that
string will be considered the line delimiter and the attribute will be set
at the beginning of each line of the passed string and reset at the end of
each line.  This is often desirable if the output contains newlines and
you're using background colors, since a background color that persists
across a newline is often interpreted by the terminal as providing the
default background color for the next line.  Programs like pagers can also
be confused by attributes that span lines.  Normally you'll want to set
\&\f(CW$Term::ANSIColor::EACHLINE\fR to \f(CW"\en"\fR to use this feature.
.SS "Constant Interface"
.IX Subsection "Constant Interface"
Alternately, if you import \f(CW\*(C`:constants\*(C'\fR, you can use the constants \s-1CLEAR\s0,
\&\s-1RESET\s0, \s-1BOLD\s0, \s-1DARK\s0, \s-1FAINT\s0, \s-1UNDERLINE\s0, \s-1UNDERSCORE\s0, \s-1BLINK\s0, \s-1REVERSE\s0,
\&\s-1CONCEALED\s0, \s-1BLACK\s0, \s-1RED\s0, \s-1GREEN\s0, \s-1YELLOW\s0, \s-1BLUE\s0, \s-1MAGENTA\s0, \s-1CYAN\s0, \s-1WHITE\s0,
\&\s-1ON_BLACK\s0, \s-1ON_RED\s0, \s-1ON_GREEN\s0, \s-1ON_YELLOW\s0, \s-1ON_BLUE\s0, \s-1ON_MAGENTA\s0, \s-1ON_CYAN\s0, and
\&\s-1ON_WHITE\s0 directly.  These are the same as color('attribute') and can be
used if you prefer typing:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text", RESET, "\en";
.Ve
.PP
to
.PP
.Vb 1
\&    print colored ("Text", \*(Aqbold blue on_white\*(Aq), "\en";
.Ve
.PP
(Note that the newline is kept separate to avoid confusing the terminal as
described above since a background color is being used.)
.PP
When using the constants, if you don't want to have to remember to add the
\&\f(CW\*(C`, RESET\*(C'\fR at the end of each print line, you can set
\&\f(CW$Term::ANSIColor::AUTORESET\fR to a true value.  Then, the display mode will
automatically be reset if there is no comma after the constant.  In other
words, with that variable set:
.PP
.Vb 1
\&    print BOLD BLUE "Text\en";
.Ve
.PP
will reset the display mode afterward, whereas:
.PP
.Vb 1
\&    print BOLD, BLUE, "Text\en";
.Ve
.PP
will not.  If you are using background colors, you will probably want to
print the newline with a separate print statement to avoid confusing the
terminal.
.PP
The subroutine interface has the advantage over the constants interface in
that only two subroutines are exported into your namespace, versus
twenty-two in the constants interface.  On the flip side, the constants
interface has the advantage of better compile time error checking, since
misspelled names of colors or attributes in calls to \fIcolor()\fR and \fIcolored()\fR
won't be caught until runtime whereas misspelled names of constants will
be caught at compile time.  So, pollute your namespace with almost two
dozen subroutines that you may not even use that often, or risk a silly
bug by mistyping an attribute.  Your choice, \s-1TMTOWTDI\s0 after all.
.SS "The Color Stack"
.IX Subsection "The Color Stack"
As of Term::ANSIColor 2.0, you can import \f(CW\*(C`:pushpop\*(C'\fR and maintain a stack
of colors using \s-1PUSHCOLOR\s0, \s-1POPCOLOR\s0, and \s-1LOCALCOLOR\s0.  \s-1PUSHCOLOR\s0 takes the
attribute string that starts its argument and pushes it onto a stack of
attributes.  \s-1POPCOLOR\s0 removes the top of the stack and restores the
previous attributes set by the argument of a prior \s-1PUSHCOLOR\s0.  \s-1LOCALCOLOR\s0
surrounds its argument in a \s-1PUSHCOLOR\s0 and \s-1POPCOLOR\s0 so that the color
resets afterward.
.PP
When using \s-1PUSHCOLOR\s0, \s-1POPCOLOR\s0, and \s-1LOCALCOLOR\s0, it's particularly
important to not put commas between the constants.
.PP
.Vb 1
\&    print PUSHCOLOR BLUE "Text\en";
.Ve
.PP
will correctly push \s-1BLUE\s0 onto the top of the stack.
.PP
.Vb 1
\&    print PUSHCOLOR, BLUE, "Text\en";    # wrong!
.Ve
.PP
will not, and a subsequent pop won't restore the correct attributes.
\&\s-1PUSHCOLOR\s0 pushes the attributes set by its argument, which is normally a
string of color constants.  It can't ask the terminal what the current
attributes are.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Bad escape sequence %s" 4
.el .IP "Bad escape sequence \f(CW%s\fR" 4
.IX Item "Bad escape sequence %s"
(F) You passed an invalid \s-1ANSI\s0 escape sequence to \fIuncolor()\fR.
.ie n .IP "Bareword ""%s"" not allowed while ""strict subs"" in use" 4
.el .IP "Bareword ``%s'' not allowed while ``strict subs'' in use" 4
.IX Item "Bareword %s not allowed while strict subs in use"
(F) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    $Foobar = FOOBAR . "This line should be blue\en";
.Ve
.Sp
or:
.Sp
.Vb 1
\&    @Foobar = FOOBAR, "This line should be blue\en";
.Ve
.Sp
This will only show up under use strict (another good reason to run under
use strict).
.ie n .IP "Invalid attribute name %s" 4
.el .IP "Invalid attribute name \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s"
(F) You passed an invalid attribute name to either \fIcolor()\fR or \fIcolored()\fR.
.ie n .IP "Name ""%s"" used only once: possible typo" 4
.el .IP "Name ``%s'' used only once: possible typo" 4
.IX Item "Name %s used only once: possible typo"
(W) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR "This text is color FOOBAR\en";
.Ve
.Sp
It's probably better to always use commas after constant names in order to
force the next error.
.IP "No comma allowed after filehandle" 4
.IX Item "No comma allowed after filehandle"
(F) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR, "This text is color FOOBAR\en";
.Ve
.Sp
Generating this fatal compile error is one of the main advantages of using
the constants interface, since you'll immediately know if you mistype a
color name.
.ie n .IP "No name for escape sequence %s" 4
.el .IP "No name for escape sequence \f(CW%s\fR" 4
.IX Item "No name for escape sequence %s"
(F) The \s-1ANSI\s0 escape sequence passed to \fIuncolor()\fR contains escapes which
aren't recognized and can't be translated to names.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1ANSI_COLORS_DISABLED\s0" 4
.IX Item "ANSI_COLORS_DISABLED"
If this environment variable is set, all of the functions defined by this
module (\fIcolor()\fR, \fIcolored()\fR, and all of the constants not previously used
in the program) will not output any escape sequences and instead will just
return the empty string or pass through the original text as appropriate.
This is intended to support easy use of scripts using this module on
platforms that don't support \s-1ANSI\s0 escape sequences.
.Sp
For it to have its proper effect, this environment variable must be set
before any color constants are used in the program.
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
It would be nice if one could leave off the commas around the constants
entirely and just say:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text\en" RESET;
.Ve
.PP
but the syntax of Perl doesn't allow this.  You need a comma after the
string.  (Of course, you may consider it a bug that commas between all the
constants aren't required, in which case you may feel free to insert
commas unless you're using \f(CW$Term::ANSIColor::AUTORESET\fR or
\&\s-1PUSHCOLOR/POPCOLOR\s0.)
.PP
For easier debugging, you may prefer to always use the commas when not
setting \f(CW$Term::ANSIColor::AUTORESET\fR or \s-1PUSHCOLOR/POPCOLOR\s0 so that you'll
get a fatal compile error rather than a warning.
.SH "NOTES"
.IX Header "NOTES"
The codes generated by this module are standard terminal control codes,
complying with \s-1ECMA\-048\s0 and \s-1ISO\s0 6429 (generally referred to as \*(L"\s-1ANSI\s0
color\*(R" for the color codes).  The non-color control codes (bold, dark,
italic, underline, and reverse) are part of the earlier \s-1ANSI\s0 X3.64
standard for control sequences for video terminals and peripherals.
.PP
Note that not all displays are \s-1ISO\s0 6429\-compliant, or even X3.64\-compliant
(or are even attempting to be so).  This module will not work as expected
on displays that do not honor these escape sequences, such as cmd.exe,
4nt.exe, and command.com under either Windows \s-1NT\s0 or Windows 2000.  They
may just be ignored, or they may display as an \s-1ESC\s0 character followed by
some apparent garbage.
.PP
Jean Delvare provided the following table of different common terminal
emulators and their support for the various attributes and others have
helped me flesh it out:
.PP
.Vb 12
\&              clear    bold     faint   under    blink   reverse  conceal
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& xterm         yes      yes      no      yes      yes      yes      yes
\& linux         yes      yes      yes    bold      yes      yes      no
\& rxvt          yes      yes      no      yes  bold/black   yes      no
\& dtterm        yes      yes      yes     yes    reverse    yes      yes
\& teraterm      yes    reverse    no      yes    rev/red    yes      no
\& aixterm      kinda   normal     no      yes      no       yes      yes
\& PuTTY         yes     color     no      yes      no       yes      no
\& Windows       yes      no       no      no       no       yes      no
\& Cygwin SSH    yes      yes      no     color    color    color     yes
\& Mac Terminal  yes      yes      no      yes      yes      yes      yes
.Ve
.PP
Windows is Windows telnet, Cygwin \s-1SSH\s0 is the OpenSSH implementation under
Cygwin on Windows \s-1NT\s0, and Mac Terminal is the Terminal application in Mac
\&\s-1OS\s0 X.  Where the entry is other than yes or no, that emulator displays the
given attribute as something else instead.  Note that on an aixterm, clear
doesn't reset colors; you have to explicitly set the colors back to what
you want.  More entries in this table are welcome.
.PP
Note that codes 3 (italic), 6 (rapid blink), and 9 (strike-through) are
specified in \s-1ANSI\s0 X3.64 and \s-1ECMA\-048\s0 but are not commonly supported by
most displays and emulators and therefore aren't supported by this module
at the present time.  \s-1ECMA\-048\s0 also specifies a large number of other
attributes, including a sequence of attributes for font changes, Fraktur
characters, double-underlining, framing, circling, and overlining.  As
none of these attributes are widely supported or useful, they also aren't
currently supported by this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1ECMA\-048\s0 is available on-line (at least at the time of this writing) at
http://www.ecma\-international.org/publications/standards/ECMA\-048.HTM <http://www.ecma-international.org/publications/standards/ECMA-048.HTM>.
.PP
\&\s-1ISO\s0 6429 is available from \s-1ISO\s0 for a charge; the author of this module
does not own a copy of it.  Since the source material for \s-1ISO\s0 6429 was
\&\s-1ECMA\-048\s0 and the latter is available for free, there seems little reason
to obtain the \s-1ISO\s0 standard.
.PP
The current version of this module is always available from its web site
at <http://www.eyrie.org/~eagle/software/ansicolor/>.  It is also part of
the Perl core distribution as of 5.6.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Original idea (using constants) by Zenin, reimplemented using subs by Russ
Allbery <rra@stanford.edu>, and then combined with the original idea by
Russ with input from Zenin.  Russ Allbery now maintains this module.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009 Russ
Allbery <rra@stanford.edu> and Zenin.  This program is free software; you
may redistribute it and/or modify it under the same terms as Perl itself.
.PP
\&\s-1PUSHCOLOR\s0, \s-1POPCOLOR\s0, and \s-1LOCALCOLOR\s0 were contributed by openmethods.com
voice solutions.

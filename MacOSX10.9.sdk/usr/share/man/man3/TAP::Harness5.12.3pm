.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Harness 3pm"
.TH TAP::Harness 3pm "2012-11-03" "perl v5.12.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Harness \- Run test scripts with statistics
.SH "VERSION"
.IX Header "VERSION"
Version 3.17
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple test harness which allows tests to be run and results
automatically aggregated and output to \s-1STDOUT\s0.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use TAP::Harness;
\& my $harness = TAP::Harness\->new( \e%args );
\& $harness\->runtests(@tests);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 5
\& my %args = (
\&    verbosity => 1,
\&    lib     => [ \*(Aqlib\*(Aq, \*(Aqblib/lib\*(Aq, \*(Aqblib/arch\*(Aq ],
\& )
\& my $harness = TAP::Harness\->new( \e%args );
.Ve
.PP
The constructor returns a new \f(CW\*(C`TAP::Harness\*(C'\fR object. It accepts an
optional hashref whose allowed keys are:
.IP "\(bu" 4
\&\f(CW\*(C`verbosity\*(C'\fR
.Sp
Set the verbosity level:
.Sp
.Vb 6
\&     1   verbose        Print individual test results to STDOUT.
\&     0   normal
\&    \-1   quiet          Suppress some test output (mostly failures 
\&                        while tests are running).
\&    \-2   really quiet   Suppress everything but the tests summary.
\&    \-3   silent         Suppress everything.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`timer\*(C'\fR
.Sp
Append run time for each test to output. Uses Time::HiRes if
available.
.IP "\(bu" 4
\&\f(CW\*(C`failures\*(C'\fR
.Sp
Show test failures (this is a no-op if \f(CW\*(C`verbose\*(C'\fR is selected).
.IP "\(bu" 4
\&\f(CW\*(C`comments\*(C'\fR
.Sp
Show test comments (this is a no-op if \f(CW\*(C`verbose\*(C'\fR is selected).
.IP "\(bu" 4
\&\f(CW\*(C`show_count\*(C'\fR
.Sp
Update the running test count during testing.
.IP "\(bu" 4
\&\f(CW\*(C`normalize\*(C'\fR
.Sp
Set to a true value to normalize the \s-1TAP\s0 that is emitted in verbose modes.
.IP "\(bu" 4
\&\f(CW\*(C`lib\*(C'\fR
.Sp
Accepts a scalar value or array ref of scalar values indicating which
paths to allowed libraries should be included if Perl tests are
executed. Naturally, this only makes sense in the context of tests
written in Perl.
.IP "\(bu" 4
\&\f(CW\*(C`switches\*(C'\fR
.Sp
Accepts a scalar value or array ref of scalar values indicating which
switches should be included if Perl tests are executed. Naturally, this
only makes sense in the context of tests written in Perl.
.IP "\(bu" 4
\&\f(CW\*(C`test_args\*(C'\fR
.Sp
A reference to an \f(CW@INC\fR style array of arguments to be passed to each
test program.
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR
.Sp
Attempt to produce color output.
.IP "\(bu" 4
\&\f(CW\*(C`exec\*(C'\fR
.Sp
Typically, Perl tests are run through this. However, anything which
spits out \s-1TAP\s0 is fine. You can use this argument to specify the name of
the program (and optional switches) to run your tests with:
.Sp
.Vb 1
\&  exec => [\*(Aq/usr/bin/ruby\*(Aq, \*(Aq\-w\*(Aq]
.Ve
.Sp
You can also pass a subroutine reference in order to determine and
return the proper program to run based on a given test script. The
subroutine reference should expect the TAP::Harness object itself as the
first argument, and the file name as the second argument. It should
return an array reference containing the command to be run and including
the test file name. It can also simply return \f(CW\*(C`undef\*(C'\fR, in which case
TAP::Harness will fall back on executing the test script in Perl:
.Sp
.Vb 2
\&    exec => sub {
\&        my ( $harness, $test_file ) = @_;
\&
\&        # Let Perl tests run.
\&        return undef if $test_file =~ /[.]t$/;
\&        return [ qw( /usr/bin/ruby \-w ), $test_file ]
\&          if $test_file =~ /[.]rb$/;
\&      }
.Ve
.Sp
If the subroutine returns a scalar with a newline or a filehandle, it
will be interpreted as raw \s-1TAP\s0 or as a \s-1TAP\s0 stream, respectively.
.IP "\(bu" 4
\&\f(CW\*(C`merge\*(C'\fR
.Sp
If \f(CW\*(C`merge\*(C'\fR is true the harness will create parsers that merge \s-1STDOUT\s0
and \s-1STDERR\s0 together for any processes they start.
.IP "\(bu" 4
\&\f(CW\*(C`aggregator_class\*(C'\fR
.Sp
The name of the class to use to aggregate test results. The default is
TAP::Parser::Aggregator.
.IP "\(bu" 4
\&\f(CW\*(C`formatter_class\*(C'\fR
.Sp
The name of the class to use to format output. The default is
TAP::Formatter::Console, or TAP::Formatter::File if the output
isn't a \s-1TTY\s0.
.IP "\(bu" 4
\&\f(CW\*(C`multiplexer_class\*(C'\fR
.Sp
The name of the class to use to multiplex tests during parallel testing.
The default is TAP::Parser::Multiplexer.
.IP "\(bu" 4
\&\f(CW\*(C`parser_class\*(C'\fR
.Sp
The name of the class to use to parse \s-1TAP\s0. The default is
TAP::Parser.
.IP "\(bu" 4
\&\f(CW\*(C`scheduler_class\*(C'\fR
.Sp
The name of the class to use to schedule test execution. The default is
TAP::Parser::Scheduler.
.IP "\(bu" 4
\&\f(CW\*(C`formatter\*(C'\fR
.Sp
If set \f(CW\*(C`formatter\*(C'\fR must be an object that is capable of formatting the
\&\s-1TAP\s0 output. See TAP::Formatter::Console for an example.
.IP "\(bu" 4
\&\f(CW\*(C`errors\*(C'\fR
.Sp
If parse errors are found in the \s-1TAP\s0 output, a note of this will be
made in the summary report. To see all of the parse errors, set this
argument to true:
.Sp
.Vb 1
\&  errors => 1
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`directives\*(C'\fR
.Sp
If set to a true value, only test results with directives will be
displayed. This overrides other settings such as \f(CW\*(C`verbose\*(C'\fR or
\&\f(CW\*(C`failures\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`ignore_exit\*(C'\fR
.Sp
If set to a true value instruct \f(CW\*(C`TAP::Parser\*(C'\fR to ignore exit and wait
status from test scripts.
.IP "\(bu" 4
\&\f(CW\*(C`jobs\*(C'\fR
.Sp
The maximum number of parallel tests to run at any time.  Which tests
can be run in parallel is controlled by \f(CW\*(C`rules\*(C'\fR.  The default is to
run only one test at a time.
.IP "\(bu" 4
\&\f(CW\*(C`rules\*(C'\fR
.Sp
A reference to a hash of rules that control which tests may be
executed in parallel. This is an experimental feature and the
interface may change.
.Sp
.Vb 10
\&    $harness\->rules(
\&        {   par => [
\&                { seq => \*(Aq../ext/DB_File/t/*\*(Aq },
\&                { seq => \*(Aq../ext/IO_Compress_Zlib/t/*\*(Aq },
\&                { seq => \*(Aq../lib/CPANPLUS/*\*(Aq },
\&                { seq => \*(Aq../lib/ExtUtils/t/*\*(Aq },
\&                \*(Aq*\*(Aq
\&            ]
\&        }
\&    );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`stdout\*(C'\fR
.Sp
A filehandle for catching standard output.
.PP
Any keys for which the value is \f(CW\*(C`undef\*(C'\fR will be ignored.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`runtests\*(C'\fI\fR
.IX Subsection "runtests"
.PP
.Vb 1
\&    $harness\->runtests(@tests);
.Ve
.PP
Accepts and array of \f(CW@tests\fR to be run. This should generally be the
names of test files, but this is not required. Each element in \f(CW@tests\fR
will be passed to \f(CW\*(C`TAP::Parser::new()\*(C'\fR as a \f(CW\*(C`source\*(C'\fR. See
TAP::Parser for more information.
.PP
It is possible to provide aliases that will be displayed in place of the
test name by supplying the test as a reference to an array containing
\&\f(CW\*(C`[ $test, $alias ]\*(C'\fR:
.PP
.Vb 2
\&    $harness\->runtests( [ \*(Aqt/foo.t\*(Aq, \*(AqFoo Once\*(Aq ],
\&                        [ \*(Aqt/foo.t\*(Aq, \*(AqFoo Twice\*(Aq ] );
.Ve
.PP
Normally it is an error to attempt to run the same test twice. Aliases
allow you to overcome this limitation by giving each run of the test a
unique name.
.PP
Tests will be run in the order found.
.PP
If the environment variable \f(CW\*(C`PERL_TEST_HARNESS_DUMP_TAP\*(C'\fR is defined it
should name a directory into which a copy of the raw \s-1TAP\s0 for each test
will be written. \s-1TAP\s0 is written to files named for each test.
Subdirectories will be created as needed.
.PP
Returns a TAP::Parser::Aggregator containing the test results.
.PP
\fI\f(CI\*(C`summary\*(C'\fI\fR
.IX Subsection "summary"
.PP
Output the summary for a TAP::Parser::Aggregator.
.PP
\fI\f(CI\*(C`aggregate_tests\*(C'\fI\fR
.IX Subsection "aggregate_tests"
.PP
.Vb 1
\&  $harness\->aggregate_tests( $aggregate, @tests );
.Ve
.PP
Run the named tests and display a summary of result. Tests will be run
in the order found.
.PP
Test results will be added to the supplied TAP::Parser::Aggregator.
\&\f(CW\*(C`aggregate_tests\*(C'\fR may be called multiple times to run several sets of
tests. Multiple \f(CW\*(C`Test::Harness\*(C'\fR instances may be used to pass results
to a single aggregator so that different parts of a complex test suite
may be run using different \f(CW\*(C`TAP::Harness\*(C'\fR settings. This is useful, for
example, in the case where some tests should run in parallel but others
are unsuitable for parallel execution.
.PP
.Vb 8
\&    my $formatter   = TAP::Formatter::Console\->new;
\&    my $ser_harness = TAP::Harness\->new( { formatter => $formatter } );
\&    my $par_harness = TAP::Harness\->new(
\&        {   formatter => $formatter,
\&            jobs      => 9
\&        }
\&    );
\&    my $aggregator = TAP::Parser::Aggregator\->new;
\&
\&    $aggregator\->start();
\&    $ser_harness\->aggregate_tests( $aggregator, @ser_tests );
\&    $par_harness\->aggregate_tests( $aggregator, @par_tests );
\&    $aggregator\->stop();
\&    $formatter\->summary($aggregator);
.Ve
.PP
Note that for simpler testing requirements it will often be possible to
replace the above code with a single call to \f(CW\*(C`runtests\*(C'\fR.
.PP
Each elements of the \f(CW@tests\fR array is either
.IP "\(bu" 4
the file name of a test script to run
.IP "\(bu" 4
a reference to a [ file name, display name ] array
.PP
When you supply a separate display name it becomes possible to run a
test more than once; the display name is effectively the alias by which
the test is known inside the harness. The harness doesn't care if it
runs the same script more than once when each invocation uses a
different name.
.PP
\fI\f(CI\*(C`make_scheduler\*(C'\fI\fR
.IX Subsection "make_scheduler"
.PP
Called by the harness when it needs to create a
TAP::Parser::Scheduler. Override in a subclass to provide an
alternative scheduler. \f(CW\*(C`make_scheduler\*(C'\fR is passed the list of tests
that was passed to \f(CW\*(C`aggregate_tests\*(C'\fR.
.PP
\fI\f(CI\*(C`jobs\*(C'\fI\fR
.IX Subsection "jobs"
.PP
Gets or sets the number of concurrent test runs the harness is
handling.  By default, this value is 1 \*(-- for parallel testing, this
should be set higher.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
\&\f(CW\*(C`TAP::Harness\*(C'\fR is designed to be (mostly) easy to subclass. If you
don't like how a particular feature functions, just override the
desired methods.
.SS "Methods"
.IX Subsection "Methods"
\&\s-1TODO:\s0 This is out of date
.PP
The following methods are ones you may wish to override if you want to
subclass \f(CW\*(C`TAP::Harness\*(C'\fR.
.PP
\fI\f(CI\*(C`summary\*(C'\fI\fR
.IX Subsection "summary"
.PP
.Vb 1
\&  $harness\->summary( \e%args );
.Ve
.PP
\&\f(CW\*(C`summary\*(C'\fR prints the summary report after all tests are run. The
argument is a hashref with the following keys:
.IP "\(bu" 4
\&\f(CW\*(C`start\*(C'\fR
.Sp
This is created with \f(CW\*(C`Benchmark\->new\*(C'\fR and it the time the tests
started. You can print a useful summary time, if desired, with:
.Sp
.Vb 2
\&    $self\->output(
\&        timestr( timediff( Benchmark\->new, $start_time ), \*(Aqnop\*(Aq ) );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`tests\*(C'\fR
.Sp
This is an array reference of all test names. To get the TAP::Parser
object for individual tests:
.Sp
.Vb 2
\& my $aggregate = $args\->{aggregate};
\& my $tests     = $args\->{tests};
\&
\& for my $name ( @$tests ) {
\&     my ($parser) = $aggregate\->parsers($test);
\&     ... do something with $parser
\& }
.Ve
.Sp
This is a bit clunky and will be cleaned up in a later release.
.PP
\fI\f(CI\*(C`make_parser\*(C'\fI\fR
.IX Subsection "make_parser"
.PP
Make a new parser and display formatter session. Typically used and/or
overridden in subclasses.
.PP
.Vb 1
\&    my ( $parser, $session ) = $harness\->make_parser;
.Ve
.PP
\fI\f(CI\*(C`finish_parser\*(C'\fI\fR
.IX Subsection "finish_parser"
.PP
Terminate use of a parser. Typically used and/or overridden in
subclasses. The parser isn't destroyed as a result of this.
.SH "REPLACING"
.IX Header "REPLACING"
If you like the \f(CW\*(C`prove\*(C'\fR utility and TAP::Parser but you want your
own harness, all you need to do is write one and provide \f(CW\*(C`new\*(C'\fR and
\&\f(CW\*(C`runtests\*(C'\fR methods. Then you can use the \f(CW\*(C`prove\*(C'\fR utility like so:
.PP
.Vb 1
\& prove \-\-harness My::Test::Harness
.Ve
.PP
Note that while \f(CW\*(C`prove\*(C'\fR accepts a list of tests (or things to be
tested), \f(CW\*(C`new\*(C'\fR has a fairly rich set of arguments. You'll probably want
to read over this code carefully to see how all of them are being used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Harness

.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Meta::Recipe3 3"
.TH Moose::Cookbook::Meta::Recipe3 3 "2011-09-06" "perl v5.12.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Meta::Recipe3 \- Labels implemented via attribute traits
.SH "VERSION"
.IX Header "VERSION"
version 2.0205
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package MyApp::Meta::Attribute::Trait::Labeled;
\&  use Moose::Role;
\&
\&  has label => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_label\*(Aq,
\&  );
\&
\&  package Moose::Meta::Attribute::Custom::Trait::Labeled;
\&  sub register_implementation {\*(AqMyApp::Meta::Attribute::Trait::Labeled\*(Aq}
\&
\&  package MyApp::Website;
\&  use Moose;
\&
\&  has url => (
\&      traits => [qw/Labeled/],
\&      is     => \*(Aqrw\*(Aq,
\&      isa    => \*(AqStr\*(Aq,
\&      label  => "The site\*(Aqs URL",
\&  );
\&
\&  has name => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  sub dump {
\&      my $self = shift;
\&
\&      my $meta = $self\->meta;
\&
\&      my $dump = \*(Aq\*(Aq;
\&
\&      for my $attribute ( map { $meta\->get_attribute($_) }
\&          sort $meta\->get_attribute_list ) {
\&
\&          if (   $attribute\->does(\*(AqMyApp::Meta::Attribute::Trait::Labeled\*(Aq)
\&              && $attribute\->has_label ) {
\&              $dump .= $attribute\->label;
\&          }
\&          else {
\&              $dump .= $attribute\->name;
\&          }
\&
\&          my $reader = $attribute\->get_read_method;
\&          $dump .= ": " . $self\->$reader . "\en";
\&      }
\&
\&      return $dump;
\&  }
\&
\&  package main;
\&
\&  my $app = MyApp::Website\->new( url => "http://google.com", name => "Google" );
.Ve
.SH "BUT FIRST"
.IX Header "BUT FIRST"
This recipe is a variation on
Moose::Cookbook::Meta::Recipe2. Please read that recipe first.
.SH "MOTIVATION"
.IX Header "MOTIVATION"
In Moose::Cookbook::Meta::Recipe2, we created an attribute
metaclass which lets you provide a label for attributes.
.PP
Using a metaclass works fine until you realize you want to add a label
\&\fIand\fR an expiration, or some other combination of new behaviors. You
could create yet another metaclass which subclasses those two, but
that makes a mess, especially if you want to mix and match behaviors
across many attributes.
.PP
Fortunately, Moose provides a much saner alternative, which is to
encapsulate each extension as a role, not a class. We can make a role
which adds a label to an attribute, and could make another to
implement expiration.
.SH "TRAITS"
.IX Header "TRAITS"
Roles that apply to metaclasses have a special name: traits. Don't let
the change in nomenclature fool you, \fBtraits are just roles\fR.
.PP
\&\*(L"has\*(R" in Moose allows you to pass a \f(CW\*(C`traits\*(C'\fR parameter for an
attribute. This parameter takes a list of trait names which are
composed into an anonymous metaclass, and that anonymous metaclass is
used for the attribute.
.PP
Yes, we still have lots of metaclasses in the background, but they're
managed by Moose for you.
.PP
Traits can do anything roles can do. They can add or refine
attributes, wrap methods, provide more methods, define an interface,
etc. The only difference is that you're now changing the attribute
metaclass instead of a user-level class.
.SH "DISSECTION"
.IX Header "DISSECTION"
A side-by-side look of the code examples in this recipe and recipe 2
show that defining and using a trait is very similar to a full-blown
metaclass.
.PP
.Vb 2
\&  package MyApp::Meta::Attribute::Trait::Labeled;
\&  use Moose::Role;
\&
\&  has label => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_label\*(Aq,
\&  );
.Ve
.PP
Instead of subclassing Moose::Meta::Attribute, we define a role. As
with our metaclass in recipe 2,
registering our role allows us to refer to it by a short name.
.PP
.Vb 2
\&  package Moose::Meta::Attribute::Custom::Trait::Labeled;
\&  sub register_implementation { \*(AqMyApp::Meta::Attribute::Trait::Labeled\*(Aq }
.Ve
.PP
Moose looks for the \f(CW\*(C`register_implementation\*(C'\fR method in
\&\f(CW\*(C`Moose::Meta::Attribute::Custom::Trait::$TRAIT_NAME\*(C'\fR to find the full
name of the trait.
.PP
For the rest of the code, we will only cover what is \fIdifferent\fR from
recipe 2.
.PP
.Vb 6
\&  has url => (
\&      traits => [qw/Labeled/],
\&      is     => \*(Aqrw\*(Aq,
\&      isa    => \*(AqStr\*(Aq,
\&      label  => "The site\*(Aqs URL",
\&  );
.Ve
.PP
Instead of passing a \f(CW\*(C`metaclass\*(C'\fR parameter, this time we pass
\&\f(CW\*(C`traits\*(C'\fR. This contains a list of trait names. Moose will build an
anonymous attribute metaclass from these traits and use it for this
attribute. Passing a \f(CW\*(C`label\*(C'\fR parameter works just as it did with the
metaclass example.
.PP
.Vb 4
\&          if (   $attribute\->does(\*(AqMyApp::Meta::Attribute::Trait::Labeled\*(Aq)
\&              && $attribute\->has_label ) {
\&              $dump .= $attribute\->label;
\&          }
.Ve
.PP
In the metaclass example, we used \f(CW\*(C`$attribute\->isa\*(C'\fR. With a role,
we instead ask if the meta-attribute object \f(CW\*(C`does\*(C'\fR the required
role. If it does not do this role, the attribute meta object won't
have the \f(CW\*(C`has_label\*(C'\fR method.
.PP
That's all. Everything else is the same!
.SH "TURNING A METACLASS INTO A TRAIT"
.IX Header "TURNING A METACLASS INTO A TRAIT"
\&\*(L"But wait!\*(R" you protest. \*(L"I've already written all of my extensions as
attribute metaclasses. I don't want to break all that code out there.\*(R"
.PP
Fortunately, you can easily turn a metaclass into a trait and still
provide the original metaclass:
.PP
.Vb 4
\&  package MyApp::Meta::Attribute::Labeled;
\&  use Moose;
\&  extends \*(AqMoose::Meta::Attribute\*(Aq;
\&  with \*(AqMyApp::Meta::Attribute::Trait::Labeled\*(Aq;
\&
\&  package Moose::Meta::Attribute::Custom::Labeled;
\&  sub register_implementation { \*(AqMyApp::Meta::Attribute::Labeled\*(Aq }
.Ve
.PP
Unfortunately, going the other way (providing a trait created from a
metaclass) is more tricky.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
If you're extending your attributes, it's easier and more flexible to
provide composable bits of behavior than to subclass
Moose::Meta::Attribute. Using traits lets you cooperate with other
extensions, either from \s-1CPAN\s0 or that you might write in the
future. Moose makes it easy to create attribute metaclasses on the fly
by providing a list of trait names to \*(L"has\*(R" in Moose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

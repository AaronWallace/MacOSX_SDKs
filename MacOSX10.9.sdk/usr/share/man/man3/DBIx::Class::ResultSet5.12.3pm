.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::ResultSet 3"
.TH DBIx::Class::ResultSet 3 "2011-07-27" "perl v5.12.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::ResultSet \- Represents a query used for fetching a set of results.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  my $users_rs   = $schema\->resultset(\*(AqUser\*(Aq);
\&  while( $user = $users_rs\->next) {
\&    print $user\->username;
\&  }
\&
\&  my $registered_users_rs   = $schema\->resultset(\*(AqUser\*(Aq)\->search({ registered => 1 });
\&  my @cds_in_2005 = $schema\->resultset(\*(AqCD\*(Aq)\->search({ year => 2005 })\->all();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A ResultSet is an object which stores a set of conditions representing
a query. It is the backbone of DBIx::Class (i.e. the really
important/useful bit).
.PP
No \s-1SQL\s0 is executed on the database when a ResultSet is created, it
just stores all the conditions needed to create the query.
.PP
A basic ResultSet representing the data of an entire table is returned
by calling \f(CW\*(C`resultset\*(C'\fR on a DBIx::Class::Schema and passing in a
Source name.
.PP
.Vb 1
\&  my $users_rs = $schema\->resultset(\*(AqUser\*(Aq);
.Ve
.PP
A new ResultSet is returned from calling \*(L"search\*(R" on an existing
ResultSet. The new one will contain all the conditions of the
original, plus any new conditions added in the \f(CW\*(C`search\*(C'\fR call.
.PP
A ResultSet also incorporates an implicit iterator. \*(L"next\*(R" and \*(L"reset\*(R"
can be used to walk through all the DBIx::Class::Rows the ResultSet
represents.
.PP
The query that the ResultSet represents is \fBonly\fR executed against
the database when these methods are called:
\&\*(L"find\*(R", \*(L"next\*(R", \*(L"all\*(R", \*(L"first\*(R", \*(L"single\*(R", \*(L"count\*(R".
.PP
If a resultset is used in a numeric context it returns the \*(L"count\*(R".
However, if it is used in a boolean context it is \fBalways\fR true.  So if
you want to check if a resultset has any results, you must use \f(CW\*(C`if $rs
!= 0\*(C'\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Chaining resultsets"
.IX Subsection "Chaining resultsets"
Let's say you've got a query that needs to be run to return some data
to the user. But, you have an authorization system in place that
prevents certain users from seeing certain information. So, you want
to construct the basic query in one method, but add constraints to it in
another.
.PP
.Vb 4
\&  sub get_data {
\&    my $self = shift;
\&    my $request = $self\->get_request; # Get a request object somehow.
\&    my $schema = $self\->result_source\->schema;
\&
\&    my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({
\&      title => $request\->param(\*(Aqtitle\*(Aq),
\&      year => $request\->param(\*(Aqyear\*(Aq),
\&    });
\&
\&    $cd_rs = $self\->apply_security_policy( $cd_rs );
\&
\&    return $cd_rs\->all();
\&  }
\&
\&  sub apply_security_policy {
\&    my $self = shift;
\&    my ($rs) = @_;
\&
\&    return $rs\->search({
\&      subversive => 0,
\&    });
\&  }
.Ve
.PP
\fIResolving conditions and attributes\fR
.IX Subsection "Resolving conditions and attributes"
.PP
When a resultset is chained from another resultset, conditions and
attributes with the same keys need resolving.
.PP
\&\*(L"join\*(R", \*(L"prefetch\*(R", \*(L"+select\*(R", \*(L"+as\*(R" attributes are merged
into the existing ones from the original resultset.
.PP
The \*(L"where\*(R" and \*(L"having\*(R" attributes, and any search conditions, are
merged with an \s-1SQL\s0 \f(CW\*(C`AND\*(C'\fR to the existing condition from the original
resultset.
.PP
All other attributes are overridden by any new ones supplied in the
search attributes.
.SS "Multiple queries"
.IX Subsection "Multiple queries"
Since a resultset just defines a query, you can do all sorts of
things with it with the same object.
.PP
.Vb 5
\&  # Don\*(Aqt hit the DB yet.
\&  my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({
\&    title => \*(Aqsomething\*(Aq,
\&    year => 2009,
\&  });
\&
\&  # Each of these hits the DB individually.
\&  my $count = $cd_rs\->count;
\&  my $most_recent = $cd_rs\->get_column(\*(Aqdate_released\*(Aq)\->max();
\&  my @records = $cd_rs\->all;
.Ve
.PP
And it's not just limited to \s-1SELECT\s0 statements.
.PP
.Vb 1
\&  $cd_rs\->delete();
.Ve
.PP
This is even cooler:
.PP
.Vb 1
\&  $cd_rs\->create({ artist => \*(AqFred\*(Aq });
.Ve
.PP
Which is the same as:
.PP
.Vb 5
\&  $schema\->resultset(\*(AqCD\*(Aq)\->create({
\&    title => \*(Aqsomething\*(Aq,
\&    year => 2009,
\&    artist => \*(AqFred\*(Aq
\&  });
.Ve
.PP
See: \*(L"search\*(R", \*(L"count\*(R", \*(L"get_column\*(R", \*(L"all\*(R", \*(L"create\*(R".
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.ie n .IP "Arguments: $source, \e%$attrs" 4
.el .IP "Arguments: \f(CW$source\fR, \e%$attrs" 4
.IX Item "Arguments: $source, %$attrs"
.PD 0
.ie n .IP "Return Value: $rs" 4
.el .IP "Return Value: \f(CW$rs\fR" 4
.IX Item "Return Value: $rs"
.PD
.PP
The resultset constructor. Takes a source object (usually a
DBIx::Class::ResultSourceProxy::Table) and an attribute hash (see
\&\*(L"\s-1ATTRIBUTES\s0\*(R" below).  Does not perform any queries \*(-- these are
executed as needed by the other methods.
.PP
Generally you won't need to construct a resultset manually.  You'll
automatically get one from e.g. a \*(L"search\*(R" called in scalar context:
.PP
.Vb 1
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search({ title => \*(Aq100th Window\*(Aq });
.Ve
.PP
\&\s-1IMPORTANT:\s0 If called on an object, proxies to new_result instead so
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->new({ title => \*(AqSpoon\*(Aq });
.Ve
.PP
will return a \s-1CD\s0 object, not a ResultSet.
.SS "search"
.IX Subsection "search"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) ||  @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) ||  \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) ||  @row_objs (list context)"
.PD
.PP
.Vb 2
\&  my @cds    = $cd_rs\->search({ year => 2001 }); # "... WHERE year = 2001"
\&  my $new_rs = $cd_rs\->search({ year => 2005 });
\&
\&  my $new_rs = $cd_rs\->search([ { year => 2005 }, { year => 2004 } ]);
\&                 # year = 2005 OR year = 2004
.Ve
.PP
In list context, \f(CW\*(C`\->all()\*(C'\fR is called implicitly on the resultset, thus
returning a list of row objects instead. To avoid that, use \*(L"search_rs\*(R".
.PP
If you need to pass in additional attributes but no additional condition,
call it as \f(CW\*(C`search(undef, \e%attrs)\*(C'\fR.
.PP
.Vb 4
\&  # "SELECT name, artistid FROM $artist_table"
\&  my @all_artists = $schema\->resultset(\*(AqArtist\*(Aq)\->search(undef, {
\&    columns => [qw/name artistid/],
\&  });
.Ve
.PP
For a list of attributes that can be passed to \f(CW\*(C`search\*(C'\fR, see
\&\*(L"\s-1ATTRIBUTES\s0\*(R". For more examples of using this function, see
Searching. For a complete
documentation for the first argument, see SQL::Abstract
and its extension DBIx::Class::SQLMaker.
.PP
For more help on using joins with search, see DBIx::Class::Manual::Joining.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Note that \*(L"search\*(R" does not process/deflate any of the values passed in the
SQL::Abstract\-compatible search condition structure. This is unlike other
condition-bound methods \*(L"new\*(R", \*(L"create\*(R" and \*(L"find\*(R". The user must ensure
manually that any value passed to this method will stringify to something the
\&\s-1RDBMS\s0 knows how to deal with. A notable example is the handling of DateTime
objects, for more info see:
\&\*(L"Formatting_DateTime_objects_in_queries\*(R" in DBIx::Class::Manual::Cookbook.
.SS "search_rs"
.IX Subsection "search_rs"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
This method does the same exact thing as \fIsearch()\fR except it will
always return a resultset, even in list context.
.SS "search_literal"
.IX Subsection "search_literal"
.ie n .IP "Arguments: $sql_fragment, @bind_values" 4
.el .IP "Arguments: \f(CW$sql_fragment\fR, \f(CW@bind_values\fR" 4
.IX Item "Arguments: $sql_fragment, @bind_values"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) || @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) || \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) || @row_objs (list context)"
.PD
.PP
.Vb 2
\&  my @cds   = $cd_rs\->search_literal(\*(Aqyear = ? AND title = ?\*(Aq, qw/2001 Reload/);
\&  my $newrs = $artist_rs\->search_literal(\*(Aqname = ?\*(Aq, \*(AqMetallica\*(Aq);
.Ve
.PP
Pass a literal chunk of \s-1SQL\s0 to be added to the conditional part of the
resultset query.
.PP
\&\s-1CAVEAT:\s0 \f(CW\*(C`search_literal\*(C'\fR is provided for Class::DBI compatibility and should
only be used in that context. \f(CW\*(C`search_literal\*(C'\fR is a convenience method.
It is equivalent to calling \f(CW$schema\fR\->search(\e[]), but if you want to ensure
columns are bound correctly, use \f(CW\*(C`search\*(C'\fR.
.PP
Example of how to use \f(CW\*(C`search\*(C'\fR instead of \f(CW\*(C`search_literal\*(C'\fR
.PP
.Vb 2
\&  my @cds = $cd_rs\->search_literal(\*(Aqcdid = ? AND (artist = ? OR artist = ?)\*(Aq, (2, 1, 2));
\&  my @cds = $cd_rs\->search(\e[ \*(Aqcdid = ? AND (artist = ? OR artist = ?)\*(Aq, [ \*(Aqcdid\*(Aq, 2 ], [ \*(Aqartist\*(Aq, 1 ], [ \*(Aqartist\*(Aq, 2 ] ]);
.Ve
.PP
See \*(L"Searching\*(R" in DBIx::Class::Manual::Cookbook and
\&\*(L"Searching\*(R" in DBIx::Class::Manual::FAQ for searching techniques that do not
require \f(CW\*(C`search_literal\*(C'\fR.
.SS "find"
.IX Subsection "find"
.ie n .IP "Arguments: \e%columns_values | @pk_values, \e%attrs?" 4
.el .IP "Arguments: \e%columns_values | \f(CW@pk_values\fR, \e%attrs?" 4
.IX Item "Arguments: %columns_values | @pk_values, %attrs?"
.PD 0
.ie n .IP "Return Value: $row_object | undef" 4
.el .IP "Return Value: \f(CW$row_object\fR | undef" 4
.IX Item "Return Value: $row_object | undef"
.PD
.PP
Finds and returns a single row based on supplied criteria. Takes either a
hashref with the same format as \*(L"create\*(R" (including inference of foreign
keys from related objects), or a list of primary key values in the same
order as the primary columns
declaration on the \*(L"result_source\*(R".
.PP
In either case an attempt is made to combine conditions already existing on
the resultset with the condition passed to this method.
.PP
To aid with preparing the correct query for the storage you may supply the
\&\f(CW\*(C`key\*(C'\fR attribute, which is the name of a
unique constraint (the
unique constraint corresponding to the
primary columns is always named
\&\f(CW\*(C`primary\*(C'\fR). If the \f(CW\*(C`key\*(C'\fR attribute has been supplied, and \s-1DBIC\s0 is unable
to construct a query that satisfies the named unique constraint fully (
non-NULL values for each column member of the constraint) an exception is
thrown.
.PP
If no \f(CW\*(C`key\*(C'\fR is specified, the search is carried over all unique constraints
which are fully defined by the available condition.
.PP
If no such constraint is found, \f(CW\*(C`find\*(C'\fR currently defaults to a simple
\&\f(CW\*(C`search\->(\e%column_values)\*(C'\fR which may or may not do what you expect.
Note that this fallback behavior may be deprecated in further versions. If
you need to search with arbitrary conditions \- use \*(L"search\*(R". If the query
resulting from this fallback produces more than one row, a warning to the
effect is issued, though only the first row is constructed and returned as
\&\f(CW$row_object\fR.
.PP
In addition to \f(CW\*(C`key\*(C'\fR, \*(L"find\*(R" recognizes and applies standard
resultset attributes in the same way as \*(L"search\*(R" does.
.PP
Note that if you have extra concerns about the correctness of the resulting
query you need to specify the \f(CW\*(C`key\*(C'\fR attribute and supply the entire condition
as an argument to find (since it is not always possible to perform the
combination of the resultset condition with the supplied one, especially if
the resultset condition contains literal sql).
.PP
For example, to find a row by its primary key:
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find(5);
.Ve
.PP
You can also find a row by a specific unique constraint:
.PP
.Vb 7
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
.Ve
.PP
See also \*(L"find_or_create\*(R" and \*(L"update_or_create\*(R".
.SS "search_related"
.IX Subsection "search_related"
.ie n .IP "Arguments: $rel, $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$rel\fR, \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $rel, $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $new_resultset (scalar context) || @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$new_resultset\fR (scalar context) || \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $new_resultset (scalar context) || @row_objs (list context)"
.PD
.PP
.Vb 3
\&  $new_rs = $cd_rs\->search_related(\*(Aqartist\*(Aq, {
\&    name => \*(AqEmo\-R\-Us\*(Aq,
\&  });
.Ve
.PP
Searches the specified relationship, optionally specifying a condition and
attributes for matching records. See \*(L"\s-1ATTRIBUTES\s0\*(R" for more information.
.PP
In list context, \f(CW\*(C`\->all()\*(C'\fR is called implicitly on the resultset, thus
returning a list of row objects instead. To avoid that, use \*(L"search_related_rs\*(R".
.PP
See also \*(L"search_related_rs\*(R".
.SS "search_related_rs"
.IX Subsection "search_related_rs"
This method works exactly the same as search_related, except that
it guarantees a resultset, even in list context.
.SS "cursor"
.IX Subsection "cursor"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $cursor" 4
.el .IP "Return Value: \f(CW$cursor\fR" 4
.IX Item "Return Value: $cursor"
.PD
.PP
Returns a storage-driven cursor to the given resultset. See
DBIx::Class::Cursor for more information.
.SS "single"
.IX Subsection "single"
.ie n .IP "Arguments: $cond?" 4
.el .IP "Arguments: \f(CW$cond\fR?" 4
.IX Item "Arguments: $cond?"
.PD 0
.ie n .IP "Return Value: $row_object | undef" 4
.el .IP "Return Value: \f(CW$row_object\fR | undef" 4
.IX Item "Return Value: $row_object | undef"
.PD
.PP
.Vb 1
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->single({ year => 2001 });
.Ve
.PP
Inflates the first result without creating a cursor if the resultset has
any records in it; if not returns \f(CW\*(C`undef\*(C'\fR. Used by \*(L"find\*(R" as a lean version
of \*(L"search\*(R".
.PP
While this method can take an optional search condition (just like \*(L"search\*(R")
being a fast-code-path it does not recognize search attributes. If you need to
add extra joins or similar, call \*(L"search\*(R" and then chain-call \*(L"single\*(R" on the
DBIx::Class::ResultSet returned.
.IP "\fBNote\fR" 4
.IX Item "Note"
As of 0.08100, this method enforces the assumption that the preceding
query returns only one row. If more than one row is returned, you will receive
a warning:
.Sp
.Vb 1
\&  Query returned more than one row
.Ve
.Sp
In this case, you should be using \*(L"next\*(R" or \*(L"find\*(R" instead, or if you really
know what you are doing, use the \*(L"rows\*(R" attribute to explicitly limit the size
of the resultset.
.Sp
This method will also throw an exception if it is called on a resultset prefetching
has_many, as such a prefetch implies fetching multiple rows from the database in
order to assemble the resulting object.
.SS "get_column"
.IX Subsection "get_column"
.ie n .IP "Arguments: $cond?" 4
.el .IP "Arguments: \f(CW$cond\fR?" 4
.IX Item "Arguments: $cond?"
.PD 0
.ie n .IP "Return Value: $resultsetcolumn" 4
.el .IP "Return Value: \f(CW$resultsetcolumn\fR" 4
.IX Item "Return Value: $resultsetcolumn"
.PD
.PP
.Vb 1
\&  my $max_length = $rs\->get_column(\*(Aqlength\*(Aq)\->max;
.Ve
.PP
Returns a DBIx::Class::ResultSetColumn instance for a column of the ResultSet.
.SS "search_like"
.IX Subsection "search_like"
.ie n .IP "Arguments: $cond, \e%attrs?" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs?" 4
.IX Item "Arguments: $cond, %attrs?"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) || @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) || \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) || @row_objs (list context)"
.PD
.PP
.Vb 2
\&  # WHERE title LIKE \*(Aq%blue%\*(Aq
\&  $cd_rs = $rs\->search_like({ title => \*(Aq%blue%\*(Aq});
.Ve
.PP
Performs a search, but uses \f(CW\*(C`LIKE\*(C'\fR instead of \f(CW\*(C`=\*(C'\fR as the condition. Note
that this is simply a convenience method retained for ex Class::DBI users.
You most likely want to use \*(L"search\*(R" with specific operators.
.PP
For more information, see DBIx::Class::Manual::Cookbook.
.PP
This method is deprecated and will be removed in 0.09. Use \*(L"\fIsearch()\fR\*(R"
instead. An example conversion is:
.PP
.Vb 1
\&  \->search_like({ foo => \*(Aqbar\*(Aq });
\&
\&  # Becomes
\&
\&  \->search({ foo => { like => \*(Aqbar\*(Aq } });
.Ve
.SS "slice"
.IX Subsection "slice"
.ie n .IP "Arguments: $first, $last" 4
.el .IP "Arguments: \f(CW$first\fR, \f(CW$last\fR" 4
.IX Item "Arguments: $first, $last"
.PD 0
.ie n .IP "Return Value: $resultset (scalar context) || @row_objs (list context)" 4
.el .IP "Return Value: \f(CW$resultset\fR (scalar context) || \f(CW@row_objs\fR (list context)" 4
.IX Item "Return Value: $resultset (scalar context) || @row_objs (list context)"
.PD
.PP
Returns a resultset or object list representing a subset of elements from the
resultset slice is called on. Indexes are from 0, i.e., to get the first
three records, call:
.PP
.Vb 1
\&  my ($one, $two, $three) = $rs\->slice(0, 2);
.Ve
.SS "next"
.IX Subsection "next"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $result | undef" 4
.el .IP "Return Value: \f(CW$result\fR | undef" 4
.IX Item "Return Value: $result | undef"
.PD
.PP
Returns the next element in the resultset (\f(CW\*(C`undef\*(C'\fR is there is none).
.PP
Can be used to efficiently iterate over records in the resultset:
.PP
.Vb 4
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search;
\&  while (my $cd = $rs\->next) {
\&    print $cd\->title;
\&  }
.Ve
.PP
Note that you need to store the resultset object, and call \f(CW\*(C`next\*(C'\fR on it.
Calling \f(CW\*(C`resultset(\*(AqTable\*(Aq)\->next\*(C'\fR repeatedly will always return the
first record from the resultset.
.SS "result_source"
.IX Subsection "result_source"
.ie n .IP "Arguments: $result_source?" 4
.el .IP "Arguments: \f(CW$result_source\fR?" 4
.IX Item "Arguments: $result_source?"
.PD 0
.ie n .IP "Return Value: $result_source" 4
.el .IP "Return Value: \f(CW$result_source\fR" 4
.IX Item "Return Value: $result_source"
.PD
.PP
An accessor for the primary ResultSource object from which this ResultSet
is derived.
.SS "result_class"
.IX Subsection "result_class"
.ie n .IP "Arguments: $result_class?" 4
.el .IP "Arguments: \f(CW$result_class\fR?" 4
.IX Item "Arguments: $result_class?"
.PD 0
.ie n .IP "Return Value: $result_class" 4
.el .IP "Return Value: \f(CW$result_class\fR" 4
.IX Item "Return Value: $result_class"
.PD
.PP
An accessor for the class to use when creating row objects. Defaults to
\&\f(CW\*(C`result_source\->result_class\*(C'\fR \- which in most cases is the name of the
\&\*(L"table\*(R" class.
.PP
Note that changing the result_class will also remove any components
that were originally loaded in the source class via
\&\*(L"load_components\*(R" in DBIx::Class::ResultSource. Any overloaded methods
in the original source class will not run.
.SS "count"
.IX Subsection "count"
.ie n .IP "Arguments: $cond, \e%attrs??" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs??" 4
.IX Item "Arguments: $cond, %attrs??"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Performs an \s-1SQL\s0 \f(CW\*(C`COUNT\*(C'\fR with the same query as the resultset was built
with to find the number of elements. Passing arguments is equivalent to
\&\f(CW\*(C`$rs\->search ($cond, \e%attrs)\->count\*(C'\fR
.SS "count_rs"
.IX Subsection "count_rs"
.ie n .IP "Arguments: $cond, \e%attrs??" 4
.el .IP "Arguments: \f(CW$cond\fR, \e%attrs??" 4
.IX Item "Arguments: $cond, %attrs??"
.PD 0
.ie n .IP "Return Value: $count_rs" 4
.el .IP "Return Value: \f(CW$count_rs\fR" 4
.IX Item "Return Value: $count_rs"
.PD
.PP
Same as \*(L"count\*(R" but returns a DBIx::Class::ResultSetColumn object.
This can be very handy for subqueries:
.PP
.Vb 1
\&  \->search( { amount => $some_rs\->count_rs\->as_query } )
.Ve
.PP
As with regular resultsets the \s-1SQL\s0 query will be executed only after
the resultset is accessed via \*(L"next\*(R" or \*(L"all\*(R". That would return
the same single value obtainable via \*(L"count\*(R".
.SS "count_literal"
.IX Subsection "count_literal"
.ie n .IP "Arguments: $sql_fragment, @bind_values" 4
.el .IP "Arguments: \f(CW$sql_fragment\fR, \f(CW@bind_values\fR" 4
.IX Item "Arguments: $sql_fragment, @bind_values"
.PD 0
.ie n .IP "Return Value: $count" 4
.el .IP "Return Value: \f(CW$count\fR" 4
.IX Item "Return Value: $count"
.PD
.PP
Counts the results in a literal query. Equivalent to calling \*(L"search_literal\*(R"
with the passed arguments, then \*(L"count\*(R".
.SS "all"
.IX Subsection "all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: @objects" 4
.el .IP "Return Value: \f(CW@objects\fR" 4
.IX Item "Return Value: @objects"
.PD
.PP
Returns all elements in the resultset.
.SS "reset"
.IX Subsection "reset"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $self" 4
.el .IP "Return Value: \f(CW$self\fR" 4
.IX Item "Return Value: $self"
.PD
.PP
Resets the resultset's cursor, so you can iterate through the elements again.
Implicitly resets the storage cursor, so a subsequent \*(L"next\*(R" will trigger
another query.
.SS "first"
.IX Subsection "first"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $object | undef" 4
.el .IP "Return Value: \f(CW$object\fR | undef" 4
.IX Item "Return Value: $object | undef"
.PD
.PP
Resets the resultset and returns an object for the first result (or \f(CW\*(C`undef\*(C'\fR
if the resultset is empty).
.SS "update"
.IX Subsection "update"
.IP "Arguments: \e%values" 4
.IX Item "Arguments: %values"
.PD 0
.ie n .IP "Return Value: $storage_rv" 4
.el .IP "Return Value: \f(CW$storage_rv\fR" 4
.IX Item "Return Value: $storage_rv"
.PD
.PP
Sets the specified columns in the resultset to the supplied values in a
single query. Note that this will not run any accessor/set_column/update
triggers, nor will it update any row object instances derived from this
resultset (this includes the contents of the resultset cache
if any). See \*(L"update_all\*(R" if you need to execute any on-update
triggers or cascades defined either by you or a
result component.
.PP
The return value is a pass through of what the underlying
storage backend returned, and may vary. See \*(L"execute\*(R" in \s-1DBI\s0 for the most
common case.
.PP
\fI\s-1CAVEAT\s0\fR
.IX Subsection "CAVEAT"
.PP
Note that \*(L"update\*(R" does not process/deflate any of the values passed in.
This is unlike the corresponding \*(L"update\*(R" in DBIx::Class::Row. The user must
ensure manually that any value passed to this method will stringify to
something the \s-1RDBMS\s0 knows how to deal with. A notable example is the
handling of DateTime objects, for more info see:
\&\*(L"Formatting_DateTime_objects_in_queries\*(R" in DBIx::Class::Manual::Cookbook.
.SS "update_all"
.IX Subsection "update_all"
.IP "Arguments: \e%values" 4
.IX Item "Arguments: %values"
.PD 0
.IP "Return Value: 1" 4
.IX Item "Return Value: 1"
.PD
.PP
Fetches all objects and updates them one at a time via
\&\*(L"update\*(R" in DBIx::Class::Row. Note that \f(CW\*(C`update_all\*(C'\fR will run \s-1DBIC\s0 defined
triggers, while \*(L"update\*(R" will not.
.SS "delete"
.IX Subsection "delete"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $storage_rv" 4
.el .IP "Return Value: \f(CW$storage_rv\fR" 4
.IX Item "Return Value: $storage_rv"
.PD
.PP
Deletes the rows matching this resultset in a single query. Note that this
will not run any delete triggers, nor will it alter the
in_storage status of any row object instances
derived from this resultset (this includes the contents of the
resultset cache if any). See \*(L"delete_all\*(R" if you need to
execute any on-delete triggers or cascades defined either by you or a
result component.
.PP
The return value is a pass through of what the underlying storage backend
returned, and may vary. See \*(L"execute\*(R" in \s-1DBI\s0 for the most common case.
.SS "delete_all"
.IX Subsection "delete_all"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: 1" 4
.IX Item "Return Value: 1"
.PD
.PP
Fetches all objects and deletes them one at a time via
\&\*(L"delete\*(R" in DBIx::Class::Row. Note that \f(CW\*(C`delete_all\*(C'\fR will run \s-1DBIC\s0 defined
triggers, while \*(L"delete\*(R" will not.
.SS "populate"
.IX Subsection "populate"
.IP "Arguments: \e@data;" 4
.IX Item "Arguments: @data;"
.PP
Accepts either an arrayref of hashrefs or alternatively an arrayref of arrayrefs.
For the arrayref of hashrefs style each hashref should be a structure suitable
for submitting to a \f(CW$resultset\fR\->create(...) method.
.PP
In void context, \f(CW\*(C`insert_bulk\*(C'\fR in DBIx::Class::Storage::DBI is used
to insert the data, as this is a faster method.
.PP
Otherwise, each set of data is inserted into the database using
\&\*(L"create\*(R" in DBIx::Class::ResultSet, and the resulting objects are
accumulated into an array. The array itself, or an array reference
is returned depending on scalar or list context.
.PP
Example:  Assuming an Artist Class that has many CDs Classes relating:
.PP
.Vb 1
\&  my $Artist_rs = $schema\->resultset("Artist");
\&
\&  ## Void Context Example
\&  $Artist_rs\->populate([
\&     { artistid => 4, name => \*(AqManufactured Crap\*(Aq, cds => [
\&        { title => \*(AqMy First CD\*(Aq, year => 2006 },
\&        { title => \*(AqYet More Tweeny\-Pop crap\*(Aq, year => 2007 },
\&      ],
\&     },
\&     { artistid => 5, name => \*(AqAngsty\-Whiny Girl\*(Aq, cds => [
\&        { title => \*(AqMy parents sold me to a record company\*(Aq, year => 2005 },
\&        { title => \*(AqWhy Am I So Ugly?\*(Aq, year => 2006 },
\&        { title => \*(AqI Got Surgery and am now Popular\*(Aq, year => 2007 }
\&      ],
\&     },
\&  ]);
\&
\&  ## Array Context Example
\&  my ($ArtistOne, $ArtistTwo, $ArtistThree) = $Artist_rs\->populate([
\&    { name => "Artist One"},
\&    { name => "Artist Two"},
\&    { name => "Artist Three", cds=> [
\&    { title => "First CD", year => 2007},
\&    { title => "Second CD", year => 2008},
\&  ]}
\&  ]);
\&
\&  print $ArtistOne\->name; ## response is \*(AqArtist One\*(Aq
\&  print $ArtistThree\->cds\->count ## reponse is \*(Aq2\*(Aq
.Ve
.PP
For the arrayref of arrayrefs style,  the first element should be a list of the
fieldsnames to which the remaining elements are rows being inserted.  For
example:
.PP
.Vb 6
\&  $Arstist_rs\->populate([
\&    [qw/artistid name/],
\&    [100, \*(AqA Formally Unknown Singer\*(Aq],
\&    [101, \*(AqA singer that jumped the shark two albums ago\*(Aq],
\&    [102, \*(AqAn actually cool singer\*(Aq],
\&  ]);
.Ve
.PP
Please note an important effect on your data when choosing between void and
wantarray context. Since void context goes straight to \f(CW\*(C`insert_bulk\*(C'\fR in
DBIx::Class::Storage::DBI this will skip any component that is overriding
\&\f(CW\*(C`insert\*(C'\fR.  So if you are using something like DBIx-Class-UUIDColumns to
create primary keys for you, you will find that your PKs are empty.  In this
case you will have to use the wantarray context in order to create those
values.
.SS "pager"
.IX Subsection "pager"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $pager" 4
.el .IP "Return Value: \f(CW$pager\fR" 4
.IX Item "Return Value: $pager"
.PD
.PP
Return Value a Data::Page object for the current resultset. Only makes
sense for queries with a \f(CW\*(C`page\*(C'\fR attribute.
.PP
To get the full count of entries for a paged resultset, call
\&\f(CW\*(C`total_entries\*(C'\fR on the Data::Page object.
.SS "page"
.IX Subsection "page"
.ie n .IP "Arguments: $page_number" 4
.el .IP "Arguments: \f(CW$page_number\fR" 4
.IX Item "Arguments: $page_number"
.PD 0
.ie n .IP "Return Value: $rs" 4
.el .IP "Return Value: \f(CW$rs\fR" 4
.IX Item "Return Value: $rs"
.PD
.PP
Returns a resultset for the \f(CW$page_number\fR page of the resultset on which page
is called, where each page contains a number of rows equal to the 'rows'
attribute set on the resultset (10 by default).
.SS "new_result"
.IX Subsection "new_result"
.IP "Arguments: \e%vals" 4
.IX Item "Arguments: %vals"
.PD 0
.ie n .IP "Return Value: $rowobject" 4
.el .IP "Return Value: \f(CW$rowobject\fR" 4
.IX Item "Return Value: $rowobject"
.PD
.PP
Creates a new row object in the resultset's result class and returns
it. The row is not inserted into the database at this point, call
\&\*(L"insert\*(R" in DBIx::Class::Row to do that. Calling \*(L"in_storage\*(R" in DBIx::Class::Row
will tell you whether the row object has been inserted or not.
.PP
Passes the hashref of input on to \*(L"new\*(R" in DBIx::Class::Row.
.SS "as_query"
.IX Subsection "as_query"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: \e[ $sql, @bind ]" 4
.el .IP "Return Value: \e[ \f(CW$sql\fR, \f(CW@bind\fR ]" 4
.IX Item "Return Value: [ $sql, @bind ]"
.PD
.PP
Returns the \s-1SQL\s0 query and bind vars associated with the invocant.
.PP
This is generally used as the \s-1RHS\s0 for a subquery.
.SS "find_or_new"
.IX Subsection "find_or_new"
.IP "Arguments: \e%vals, \e%attrs?" 4
.IX Item "Arguments: %vals, %attrs?"
.PD 0
.ie n .IP "Return Value: $rowobject" 4
.el .IP "Return Value: \f(CW$rowobject\fR" 4
.IX Item "Return Value: $rowobject"
.PD
.PP
.Vb 2
\&  my $artist = $schema\->resultset(\*(AqArtist\*(Aq)\->find_or_new(
\&    { artist => \*(Aqfred\*(Aq }, { key => \*(Aqartists\*(Aq });
\&
\&  $cd\->cd_to_producer\->find_or_new({ producer => $producer },
\&                                   { key => \*(Aqprimary });
.Ve
.PP
Find an existing record from this resultset using \*(L"find\*(R". if none exists,
instantiate a new result object and return it. The object will not be saved
into your storage until you call \*(L"insert\*(R" in DBIx::Class::Row on it.
.PP
You most likely want this method when looking for existing rows using a unique
constraint that is not the primary key, or looking for related rows.
.PP
If you want objects to be saved immediately, use \*(L"find_or_create\*(R" instead.
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious new objects.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`find_or_new\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`find_or_new\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.SS "create"
.IX Subsection "create"
.IP "Arguments: \e%vals" 4
.IX Item "Arguments: %vals"
.PD 0
.ie n .IP "Return Value: a DBIx::Class::Row $object" 4
.el .IP "Return Value: a DBIx::Class::Row \f(CW$object\fR" 4
.IX Item "Return Value: a DBIx::Class::Row $object"
.PD
.PP
Attempt to create a single new row or a row with multiple related rows
in the table represented by the resultset (and related tables). This
will not check for duplicate rows before inserting, use
\&\*(L"find_or_create\*(R" to do that.
.PP
To create one row for this resultset, pass a hashref of key/value
pairs representing the columns of the table and the values you wish to
store. If the appropriate relationships are set up, foreign key fields
can also be passed an object representing the foreign row, and the
value will be set to its primary key.
.PP
To create related objects, pass a hashref of related-object column values
\&\fBkeyed on the relationship name\fR. If the relationship is of type \f(CW\*(C`multi\*(C'\fR
(\*(L"has_many\*(R" in DBIx::Class::Relationship) \- pass an arrayref of hashrefs.
The process will correctly identify columns holding foreign keys, and will
transparently populate them from the keys of the corresponding relation.
This can be applied recursively, and will work correctly for a structure
with an arbitrary depth and width, as long as the relationships actually
exists and the correct column data has been supplied.
.PP
Instead of hashrefs of plain related data (key/value pairs), you may
also pass new or inserted objects. New objects (not inserted yet, see
\&\*(L"new\*(R"), will be inserted into their appropriate tables.
.PP
Effectively a shortcut for \f(CW\*(C`\->new_result(\e%vals)\->insert\*(C'\fR.
.PP
Example of creating a new row.
.PP
.Vb 4
\&  $person_rs\->create({
\&    name=>"Some Person",
\&    email=>"somebody@someplace.com"
\&  });
.Ve
.PP
Example of creating a new row and also creating rows in a related \f(CW\*(C`has_many\*(C'\fR
or \f(CW\*(C`has_one\*(C'\fR resultset.  Note Arrayref.
.PP
.Vb 7
\&  $artist_rs\->create(
\&     { artistid => 4, name => \*(AqManufactured Crap\*(Aq, cds => [
\&        { title => \*(AqMy First CD\*(Aq, year => 2006 },
\&        { title => \*(AqYet More Tweeny\-Pop crap\*(Aq, year => 2007 },
\&      ],
\&     },
\&  );
.Ve
.PP
Example of creating a new row and also creating a row in a related
\&\f(CW\*(C`belongs_to\*(C'\fR resultset. Note Hashref.
.PP
.Vb 7
\&  $cd_rs\->create({
\&    title=>"Music for Silly Walks",
\&    year=>2000,
\&    artist => {
\&      name=>"Silly Musician",
\&    }
\&  });
.Ve
.IP "\s-1WARNING\s0" 4
.IX Item "WARNING"
When subclassing ResultSet never attempt to override this method. Since
it is a simple shortcut for \f(CW\*(C`$self\->new_result($attrs)\->insert\*(C'\fR, a
lot of the internals simply never call it, so your override will be
bypassed more often than not. Override either new
or insert depending on how early in the
\&\*(L"create\*(R" process you need to intervene.
.SS "find_or_create"
.IX Subsection "find_or_create"
.IP "Arguments: \e%vals, \e%attrs?" 4
.IX Item "Arguments: %vals, %attrs?"
.PD 0
.ie n .IP "Return Value: $rowobject" 4
.el .IP "Return Value: \f(CW$rowobject\fR" 4
.IX Item "Return Value: $rowobject"
.PD
.PP
.Vb 2
\&  $cd\->cd_to_producer\->find_or_create({ producer => $producer },
\&                                      { key => \*(Aqprimary\*(Aq });
.Ve
.PP
Tries to find a record based on its primary key or unique constraints; if none
is found, creates one and returns that instead.
.PP
.Vb 6
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_create({
\&    cdid   => 5,
\&    artist => \*(AqMassive Attack\*(Aq,
\&    title  => \*(AqMezzanine\*(Aq,
\&    year   => 2005,
\&  });
.Ve
.PP
Also takes an optional \f(CW\*(C`key\*(C'\fR attribute, to search by a specific key or unique
constraint. For example:
.PP
.Vb 7
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->find_or_create(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious row creation.
.PP
\&\fBNote\fR: Because \fIfind_or_create()\fR reads from the database and then
possibly inserts based on the result, this method is subject to a race
condition. Another process could create a record in the table after
the find has completed and before the create has started. To avoid
this problem, use \fIfind_or_create()\fR inside a transaction.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`find_or_create\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`find_or_create\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R" and \*(L"update_or_create\*(R". For information on how to declare
unique constraints, see \*(L"add_unique_constraint\*(R" in DBIx::Class::ResultSource.
.SS "update_or_create"
.IX Subsection "update_or_create"
.ie n .IP "Arguments: \e%col_values, { key => $unique_constraint }?" 4
.el .IP "Arguments: \e%col_values, { key => \f(CW$unique_constraint\fR }?" 4
.IX Item "Arguments: %col_values, { key => $unique_constraint }?"
.PD 0
.ie n .IP "Return Value: $row_object" 4
.el .IP "Return Value: \f(CW$row_object\fR" 4
.IX Item "Return Value: $row_object"
.PD
.PP
.Vb 1
\&  $resultset\->update_or_create({ col => $val, ... });
.Ve
.PP
Like \*(L"find_or_create\*(R", but if a row is found it is immediately updated via
\&\f(CW\*(C`$found_row\->update (\e%col_values)\*(C'\fR.
.PP
Takes an optional \f(CW\*(C`key\*(C'\fR attribute to search on a specific unique constraint.
For example:
.PP
.Vb 9
\&  # In your application
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->update_or_create(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&      year   => 1998,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
\&
\&  $cd\->cd_to_producer\->update_or_create({
\&    producer => $producer,
\&    name => \*(Aqharry\*(Aq,
\&  }, {
\&    key => \*(Aqprimary\*(Aq,
\&  });
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious row creation.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`update_or_create\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`update_or_create\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R" and \*(L"find_or_create\*(R". For information on how to declare
unique constraints, see \*(L"add_unique_constraint\*(R" in DBIx::Class::ResultSource.
.SS "update_or_new"
.IX Subsection "update_or_new"
.ie n .IP "Arguments: \e%col_values, { key => $unique_constraint }?" 4
.el .IP "Arguments: \e%col_values, { key => \f(CW$unique_constraint\fR }?" 4
.IX Item "Arguments: %col_values, { key => $unique_constraint }?"
.PD 0
.ie n .IP "Return Value: $rowobject" 4
.el .IP "Return Value: \f(CW$rowobject\fR" 4
.IX Item "Return Value: $rowobject"
.PD
.PP
.Vb 1
\&  $resultset\->update_or_new({ col => $val, ... });
.Ve
.PP
Like \*(L"find_or_new\*(R" but if a row is found it is immediately updated via
\&\f(CW\*(C`$found_row\->update (\e%col_values)\*(C'\fR.
.PP
For example:
.PP
.Vb 9
\&  # In your application
\&  my $cd = $schema\->resultset(\*(AqCD\*(Aq)\->update_or_new(
\&    {
\&      artist => \*(AqMassive Attack\*(Aq,
\&      title  => \*(AqMezzanine\*(Aq,
\&      year   => 1998,
\&    },
\&    { key => \*(Aqcd_artist_title\*(Aq }
\&  );
\&
\&  if ($cd\->in_storage) {
\&      # the cd was updated
\&  }
\&  else {
\&      # the cd is not yet in the database, let\*(Aqs insert it
\&      $cd\->insert;
\&  }
.Ve
.PP
\&\fBNote\fR: Make sure to read the documentation of \*(L"find\*(R" and understand the
significance of the \f(CW\*(C`key\*(C'\fR attribute, as its lack may skew your search, and
subsequently result in spurious new objects.
.PP
\&\fBNote\fR: Take care when using \f(CW\*(C`update_or_new\*(C'\fR with a table having
columns with default values that you intend to be automatically
supplied by the database (e.g. an auto_increment primary key column).
In normal usage, the value of such columns should \s-1NOT\s0 be included at
all in the call to \f(CW\*(C`update_or_new\*(C'\fR, even when set to \f(CW\*(C`undef\*(C'\fR.
.PP
See also \*(L"find\*(R", \*(L"find_or_create\*(R" and \*(L"find_or_new\*(R".
.SS "get_cache"
.IX Subsection "get_cache"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: \e@cache_objects | undef" 4
.IX Item "Return Value: @cache_objects | undef"
.PD
.PP
Gets the contents of the cache for the resultset, if the cache is set.
.PP
The cache is populated either by using the \*(L"prefetch\*(R" attribute to
\&\*(L"search\*(R" or by calling \*(L"set_cache\*(R".
.SS "set_cache"
.IX Subsection "set_cache"
.IP "Arguments: \e@cache_objects" 4
.IX Item "Arguments: @cache_objects"
.PD 0
.IP "Return Value: \e@cache_objects" 4
.IX Item "Return Value: @cache_objects"
.PD
.PP
Sets the contents of the cache for the resultset. Expects an arrayref
of objects of the same class as those produced by the resultset. Note that
if the cache is set the resultset will return the cached objects rather
than re-querying the database even if the cache attr is not set.
.PP
The contents of the cache can also be populated by using the
\&\*(L"prefetch\*(R" attribute to \*(L"search\*(R".
.SS "clear_cache"
.IX Subsection "clear_cache"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: undef" 4
.IX Item "Return Value: undef"
.PD
.PP
Clears the cache for the resultset.
.SS "is_paged"
.IX Subsection "is_paged"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: true, if the resultset has been paginated" 4
.IX Item "Return Value: true, if the resultset has been paginated"
.PD
.SS "is_ordered"
.IX Subsection "is_ordered"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: true, if the resultset has been ordered with ""order_by""." 4
.el .IP "Return Value: true, if the resultset has been ordered with \f(CWorder_by\fR." 4
.IX Item "Return Value: true, if the resultset has been ordered with order_by."
.PD
.SS "related_resultset"
.IX Subsection "related_resultset"
.ie n .IP "Arguments: $relationship_name" 4
.el .IP "Arguments: \f(CW$relationship_name\fR" 4
.IX Item "Arguments: $relationship_name"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Returns a related resultset for the supplied relationship name.
.PP
.Vb 1
\&  $artist_rs = $schema\->resultset(\*(AqCD\*(Aq)\->related_resultset(\*(AqArtist\*(Aq);
.Ve
.SS "current_source_alias"
.IX Subsection "current_source_alias"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $source_alias" 4
.el .IP "Return Value: \f(CW$source_alias\fR" 4
.IX Item "Return Value: $source_alias"
.PD
.PP
Returns the current table alias for the result source this resultset is built
on, that will be used in the \s-1SQL\s0 query. Usually it is \f(CW\*(C`me\*(C'\fR.
.PP
Currently the source alias that refers to the result set returned by a
\&\*(L"search\*(R"/\*(L"find\*(R" family method depends on how you got to the resultset: it's
\&\f(CW\*(C`me\*(C'\fR by default, but eg. \*(L"search_related\*(R" aliases it to the related result
source name (and keeps \f(CW\*(C`me\*(C'\fR referring to the original result set). The long
term goal is to make DBIx::Class always alias the current resultset as \f(CW\*(C`me\*(C'\fR
(and make this method unnecessary).
.PP
Thus it's currently necessary to use this method in predefined queries (see
\&\*(L"Predefined searches\*(R" in DBIx::Class::Manual::Cookbook) when referring to the
source alias of the current result set:
.PP
.Vb 3
\&  # in a result set class
\&  sub modified_by {
\&    my ($self, $user) = @_;
\&
\&    my $me = $self\->current_source_alias;
\&
\&    return $self\->search(
\&      "$me.modified" => $user\->id,
\&    );
\&  }
.Ve
.SS "as_subselect_rs"
.IX Subsection "as_subselect_rs"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.ie n .IP "Return Value: $resultset" 4
.el .IP "Return Value: \f(CW$resultset\fR" 4
.IX Item "Return Value: $resultset"
.PD
.PP
Act as a barrier to \s-1SQL\s0 symbols.  The resultset provided will be made into a
\&\*(L"virtual view\*(R" by including it as a subquery within the from clause.  From this
point on, any joined tables are inaccessible to \->search on the resultset (as if
it were simply where-filtered without joins).  For example:
.PP
.Vb 1
\& my $rs = $schema\->resultset(\*(AqBar\*(Aq)\->search({\*(Aqx.name\*(Aq => \*(Aqabc\*(Aq},{ join => \*(Aqx\*(Aq });
\&
\& # \*(Aqx\*(Aq now pollutes the query namespace
\&
\& # So the following works as expected
\& my $ok_rs = $rs\->search({\*(Aqx.other\*(Aq => 1});
\&
\& # But this doesn\*(Aqt: instead of finding a \*(AqBar\*(Aq related to two x rows (abc and
\& # def) we look for one row with contradictory terms and join in another table
\& # (aliased \*(Aqx_2\*(Aq) which we never use
\& my $broken_rs = $rs\->search({\*(Aqx.name\*(Aq => \*(Aqdef\*(Aq});
\&
\& my $rs2 = $rs\->as_subselect_rs;
\&
\& # doesn\*(Aqt work \- \*(Aqx\*(Aq is no longer accessible in $rs2, having been sealed away
\& my $not_joined_rs = $rs2\->search({\*(Aqx.other\*(Aq => 1});
\&
\& # works as expected: finds a \*(Aqtable\*(Aq row related to two x rows (abc and def)
\& my $correctly_joined_rs = $rs2\->search({\*(Aqx.name\*(Aq => \*(Aqdef\*(Aq});
.Ve
.PP
Another example of when one might use this would be to select a subset of
columns in a group by clause:
.PP
.Vb 5
\& my $rs = $schema\->resultset(\*(AqBar\*(Aq)\->search(undef, {
\&   group_by => [qw{ id foo_id baz_id }],
\& })\->as_subselect_rs\->search(undef, {
\&   columns => [qw{ id foo_id }]
\& });
.Ve
.PP
In the above example normally columns would have to be equal to the group by,
but because we isolated the group by into a subselect the above works.
.SS "throw_exception"
.IX Subsection "throw_exception"
See \*(L"throw_exception\*(R" in DBIx::Class::Schema for details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Attributes are used to refine a ResultSet in various ways when
searching for data. They can be passed to any method which takes an
\&\f(CW\*(C`\e%attrs\*(C'\fR argument. See \*(L"search\*(R", \*(L"search_rs\*(R", \*(L"find\*(R",
\&\*(L"count\*(R".
.PP
These are in no particular order:
.SS "order_by"
.IX Subsection "order_by"
.ie n .IP "Value: ( $order_by | \e@order_by | \e%order_by )" 4
.el .IP "Value: ( \f(CW$order_by\fR | \e@order_by | \e%order_by )" 4
.IX Item "Value: ( $order_by | @order_by | %order_by )"
.PP
Which column(s) to order the results by.
.PP
[The full list of suitable values is documented in
\&\*(L"\s-1ORDER\s0 \s-1BY\s0 \s-1CLAUSES\s0\*(R" in SQL::Abstract; the following is a summary of
common options.]
.PP
If a single column name, or an arrayref of names is supplied, the
argument is passed through directly to \s-1SQL\s0. The hashref syntax allows
for connection-agnostic specification of ordering direction:
.PP
.Vb 1
\& For descending order:
\&
\&  order_by => { \-desc => [qw/col1 col2 col3/] }
\&
\& For explicit ascending order:
\&
\&  order_by => { \-asc => \*(Aqcol\*(Aq }
.Ve
.PP
The old scalarref syntax (i.e. order_by => \e'year \s-1DESC\s0') is still
supported, although you are strongly encouraged to use the hashref
syntax as outlined above.
.SS "columns"
.IX Subsection "columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Shortcut to request a particular set of columns to be retrieved. Each
column spec may be a string (a table column name), or a hash (in which
case the key is the \f(CW\*(C`as\*(C'\fR value, and the value is used as the \f(CW\*(C`select\*(C'\fR
expression). Adds \f(CW\*(C`me.\*(C'\fR onto the start of any column without a \f(CW\*(C`.\*(C'\fR in
it and sets \f(CW\*(C`select\*(C'\fR from that, then auto-populates \f(CW\*(C`as\*(C'\fR from
\&\f(CW\*(C`select\*(C'\fR as normal. (You may also use the \f(CW\*(C`cols\*(C'\fR attribute, as in
earlier versions of \s-1DBIC\s0.)
.PP
Essentially \f(CW\*(C`columns\*(C'\fR does the same as \*(L"select\*(R" and \*(L"as\*(R".
.PP
.Vb 1
\&    columns => [ \*(Aqfoo\*(Aq, { bar => \*(Aqbaz\*(Aq } ]
.Ve
.PP
is the same as
.PP
.Vb 2
\&    select => [qw/foo baz/],
\&    as => [qw/foo bar/]
.Ve
.SS "+columns"
.IX Subsection "+columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Indicates additional columns to be selected from storage. Works the same
as \*(L"columns\*(R" but adds columns to the selection. (You may also use the
\&\f(CW\*(C`include_columns\*(C'\fR attribute, as in earlier versions of \s-1DBIC\s0). For
example:\-
.PP
.Vb 4
\&  $schema\->resultset(\*(AqCD\*(Aq)\->search(undef, {
\&    \*(Aq+columns\*(Aq => [\*(Aqartist.name\*(Aq],
\&    join => [\*(Aqartist\*(Aq]
\&  });
.Ve
.PP
would return all CDs and include a 'name' column to the information
passed to object inflation. Note that the 'artist' is the name of the
column (or relationship) accessor, and 'name' is the name of the column
accessor in the related table.
.PP
\&\fB\s-1NOTE:\s0\fR You need to explicitly quote '+columns' when defining the attribute.
Not doing so causes Perl to incorrectly interpret +columns as a bareword with a
unary plus operator before it.
.SS "include_columns"
.IX Subsection "include_columns"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
Deprecated.  Acts as a synonym for \*(L"+columns\*(R" for backward compatibility.
.SS "select"
.IX Subsection "select"
.IP "Value: \e@select_columns" 4
.IX Item "Value: @select_columns"
.PP
Indicates which columns should be selected from the storage. You can use
column names, or in the case of \s-1RDBMS\s0 back ends, function or stored procedure
names:
.PP
.Vb 7
\&  $rs = $schema\->resultset(\*(AqEmployee\*(Aq)\->search(undef, {
\&    select => [
\&      \*(Aqname\*(Aq,
\&      { count => \*(Aqemployeeid\*(Aq },
\&      { max => { length => \*(Aqname\*(Aq }, \-as => \*(Aqlongest_name\*(Aq }
\&    ]
\&  });
\&
\&  # Equivalent SQL
\&  SELECT name, COUNT( employeeid ), MAX( LENGTH( name ) ) AS longest_name FROM employee
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR You will almost always need a corresponding \*(L"as\*(R" attribute when you
use \*(L"select\*(R", to instruct DBIx::Class how to store the result of the column.
Also note that the \*(L"as\*(R" attribute has nothing to do with the SQL-side '\s-1AS\s0'
identifier aliasing. You can however alias a function, so you can use it in
e.g. an \f(CW\*(C`ORDER BY\*(C'\fR clause. This is done via the \f(CW\*(C`\-as\*(C'\fR \fBselect function
attribute\fR supplied as shown in the example above.
.PP
\&\fB\s-1NOTE:\s0\fR You need to explicitly quote '+select'/'+as' when defining the attributes.
Not doing so causes Perl to incorrectly interpret them as a bareword with a
unary plus operator before it.
.SS "+select"
.IX Subsection "+select"
.RS 4
Indicates additional columns to be selected from storage.  Works the same as
\&\*(L"select\*(R" but adds columns to the default selection, instead of specifying
an explicit list.
.RE
.SS "+as"
.IX Subsection "+as"
.RS 4
Indicates additional column names for those added via \*(L"+select\*(R". See \*(L"as\*(R".
.RE
.SS "as"
.IX Subsection "as"
.IP "Value: \e@inflation_names" 4
.IX Item "Value: @inflation_names"
.PP
Indicates column names for object inflation. That is \*(L"as\*(R" indicates the
slot name in which the column value will be stored within the
Row object. The value will then be accessible via this
identifier by the \f(CW\*(C`get_column\*(C'\fR method (or via the object accessor \fBif one
with the same name already exists\fR) as shown below. The \*(L"as\*(R" attribute has
\&\fBnothing to do\fR with the SQL-side \f(CW\*(C`AS\*(C'\fR. See \*(L"select\*(R" for details.
.PP
.Vb 12
\&  $rs = $schema\->resultset(\*(AqEmployee\*(Aq)\->search(undef, {
\&    select => [
\&      \*(Aqname\*(Aq,
\&      { count => \*(Aqemployeeid\*(Aq },
\&      { max => { length => \*(Aqname\*(Aq }, \-as => \*(Aqlongest_name\*(Aq }
\&    ],
\&    as => [qw/
\&      name
\&      employee_count
\&      max_name_length
\&    /],
\&  });
.Ve
.PP
If the object against which the search is performed already has an accessor
matching a column name specified in \f(CW\*(C`as\*(C'\fR, the value can be retrieved using
the accessor as normal:
.PP
.Vb 1
\&  my $name = $employee\->name();
.Ve
.PP
If on the other hand an accessor does not exist in the object, you need to
use \f(CW\*(C`get_column\*(C'\fR instead:
.PP
.Vb 1
\&  my $employee_count = $employee\->get_column(\*(Aqemployee_count\*(Aq);
.Ve
.PP
You can create your own accessors if required \- see
DBIx::Class::Manual::Cookbook for details.
.SS "join"
.IX Subsection "join"
.IP "Value: ($rel_name | \e@rel_names | \e%rel_names)" 4
.IX Item "Value: ($rel_name | @rel_names | %rel_names)"
.PP
Contains a list of relationships that should be joined for this query.  For
example:
.PP
.Vb 5
\&  # Get CDs by Nine Inch Nails
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    { \*(Aqartist.name\*(Aq => \*(AqNine Inch Nails\*(Aq },
\&    { join => \*(Aqartist\*(Aq }
\&  );
.Ve
.PP
Can also contain a hash reference to refer to the other relation's relations.
For example:
.PP
.Vb 7
\&  package MyApp::Schema::Track;
\&  use base qw/DBIx::Class/;
\&  _\|_PACKAGE_\|_\->table(\*(Aqtrack\*(Aq);
\&  _\|_PACKAGE_\|_\->add_columns(qw/trackid cd position title/);
\&  _\|_PACKAGE_\|_\->set_primary_key(\*(Aqtrackid\*(Aq);
\&  _\|_PACKAGE_\|_\->belongs_to(cd => \*(AqMyApp::Schema::CD\*(Aq);
\&  1;
\&
\&  # In your application
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search(
\&    { \*(Aqtrack.title\*(Aq => \*(AqTeardrop\*(Aq },
\&    {
\&      join     => { cd => \*(Aqtrack\*(Aq },
\&      order_by => \*(Aqartist.name\*(Aq,
\&    }
\&  );
.Ve
.PP
You need to use the relationship (not the table) name in  conditions,
because they are aliased as such. The current table is aliased as \*(L"me\*(R", so
you need to use me.column_name in order to avoid ambiguity. For example:
.PP
.Vb 8
\&  # Get CDs from 1984 with a \*(AqFoo\*(Aq track
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&    {
\&      \*(Aqme.year\*(Aq => 1984,
\&      \*(Aqtracks.name\*(Aq => \*(AqFoo\*(Aq
\&    },
\&    { join => \*(Aqtracks\*(Aq }
\&  );
.Ve
.PP
If the same join is supplied twice, it will be aliased to <rel>_2 (and
similarly for a third time). For e.g.
.PP
.Vb 6
\&  my $rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({
\&    \*(Aqcds.title\*(Aq   => \*(AqDown to Earth\*(Aq,
\&    \*(Aqcds_2.title\*(Aq => \*(AqPopular\*(Aq,
\&  }, {
\&    join => [ qw/cds cds/ ],
\&  });
.Ve
.PP
will return a set of all artists that have both a cd with title 'Down
to Earth' and a cd with title 'Popular'.
.PP
If you want to fetch related objects from other tables as well, see \f(CW\*(C`prefetch\*(C'\fR
below.
.PP
For more help on using joins with search, see DBIx::Class::Manual::Joining.
.SS "prefetch"
.IX Subsection "prefetch"
.IP "Value: ($rel_name | \e@rel_names | \e%rel_names)" 4
.IX Item "Value: ($rel_name | @rel_names | %rel_names)"
.PP
Contains one or more relationships that should be fetched along with
the main query (when they are accessed afterwards the data will
already be available, without extra queries to the database).  This is
useful for when you know you will need the related objects, because it
saves at least one query:
.PP
.Vb 8
\&  my $rs = $schema\->resultset(\*(AqTag\*(Aq)\->search(
\&    undef,
\&    {
\&      prefetch => {
\&        cd => \*(Aqartist\*(Aq
\&      }
\&    }
\&  );
.Ve
.PP
The initial search results in \s-1SQL\s0 like the following:
.PP
.Vb 3
\&  SELECT tag.*, cd.*, artist.* FROM tag
\&  JOIN cd ON tag.cd = cd.cdid
\&  JOIN artist ON cd.artist = artist.artistid
.Ve
.PP
DBIx::Class has no need to go back to the database when we access the
\&\f(CW\*(C`cd\*(C'\fR or \f(CW\*(C`artist\*(C'\fR relationships, which saves us two \s-1SQL\s0 statements in this
case.
.PP
Simple prefetches will be joined automatically, so there is no need
for a \f(CW\*(C`join\*(C'\fR attribute in the above search.
.PP
\&\*(L"prefetch\*(R" can be used with the any of the relationship types and
multiple prefetches can be specified together. Below is a more complex
example that prefetches a \s-1CD\s0's artist, its liner notes (if present),
the cover image, the tracks on that cd, and the guests on those
tracks.
.PP
.Vb 5
\& # Assuming:
\& My::Schema::CD\->belongs_to( artist      => \*(AqMy::Schema::Artist\*(Aq     );
\& My::Schema::CD\->might_have( liner_note  => \*(AqMy::Schema::LinerNotes\*(Aq );
\& My::Schema::CD\->has_one(    cover_image => \*(AqMy::Schema::Artwork\*(Aq    );
\& My::Schema::CD\->has_many(   tracks      => \*(AqMy::Schema::Track\*(Aq      );
\&
\& My::Schema::Artist\->belongs_to( record_label => \*(AqMy::Schema::RecordLabel\*(Aq );
\&
\& My::Schema::Track\->has_many( guests => \*(AqMy::Schema::Guest\*(Aq );
\&
\&
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&   undef,
\&   {
\&     prefetch => [
\&       { artist => \*(Aqrecord_label\*(Aq},  # belongs_to => belongs_to
\&       \*(Aqliner_note\*(Aq,                 # might_have
\&       \*(Aqcover_image\*(Aq,                # has_one
\&       { tracks => \*(Aqguests\*(Aq },       # has_many => has_many
\&     ]
\&   }
\& );
.Ve
.PP
This will produce \s-1SQL\s0 like the following:
.PP
.Vb 10
\& SELECT cd.*, artist.*, record_label.*, liner_note.*, cover_image.*,
\&        tracks.*, guests.*
\&   FROM cd me
\&   JOIN artist artist
\&     ON artist.artistid = me.artistid
\&   JOIN record_label record_label
\&     ON record_label.labelid = artist.labelid
\&   LEFT JOIN track tracks
\&     ON tracks.cdid = me.cdid
\&   LEFT JOIN guest guests
\&     ON guests.trackid = track.trackid
\&   LEFT JOIN liner_notes liner_note
\&     ON liner_note.cdid = me.cdid
\&   JOIN cd_artwork cover_image
\&     ON cover_image.cdid = me.cdid
\& ORDER BY tracks.cd
.Ve
.PP
Now the \f(CW\*(C`artist\*(C'\fR, \f(CW\*(C`record_label\*(C'\fR, \f(CW\*(C`liner_note\*(C'\fR, \f(CW\*(C`cover_image\*(C'\fR,
\&\f(CW\*(C`tracks\*(C'\fR, and \f(CW\*(C`guests\*(C'\fR of the \s-1CD\s0 will all be available through the
relationship accessors without the need for additional queries to the
database.
.PP
However, there is one caveat to be observed: it can be dangerous to
prefetch more than one has_many
relationship on a given level. e.g.:
.PP
.Vb 9
\& my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&   undef,
\&   {
\&     prefetch => [
\&       \*(Aqtracks\*(Aq,                         # has_many
\&       { cd_to_producer => \*(Aqproducer\*(Aq }, # has_many => belongs_to (i.e. m2m)
\&     ]
\&   }
\& );
.Ve
.PP
In fact, \f(CW\*(C`DBIx::Class\*(C'\fR will emit the following warning:
.PP
.Vb 3
\& Prefetching multiple has_many rels tracks and cd_to_producer at top
\& level will explode the number of row objects retrievable via \->next
\& or \->all. Use at your own risk.
.Ve
.PP
The collapser currently can't identify duplicate tuples for multiple
has_many relationships and as a
result the second has_many
relation could contain redundant objects.
.PP
\fIUsing \*(L"prefetch\*(R" with \*(L"join\*(R"\fR
.IX Subsection "Using prefetch with join"
.PP
\&\*(L"prefetch\*(R" implies a \*(L"join\*(R" with the equivalent argument, and is
properly merged with any existing \*(L"join\*(R" specification. So the
following:
.PP
.Vb 7
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&   {\*(Aqrecord_label.name\*(Aq => \*(AqMusic Product Ltd.\*(Aq},
\&   {
\&     join     => {artist => \*(Aqrecord_label\*(Aq},
\&     prefetch => \*(Aqartist\*(Aq,
\&   }
\& );
.Ve
.PP
\&... will work, searching on the record label's name, but only
prefetching the \f(CW\*(C`artist\*(C'\fR.
.PP
\fIUsing \*(L"prefetch\*(R" with \*(L"select\*(R" / \*(L"+select\*(R" / \*(L"as\*(R" / \*(L"+as\*(R"\fR
.IX Subsection "Using prefetch with select / +select / as / +as"
.PP
\&\*(L"prefetch\*(R" implies a \*(L"+select\*(R"/\*(L"+as\*(R" with the fields of the
prefetched relations.  So given:
.PP
.Vb 8
\&  my $rs = $schema\->resultset(\*(AqCD\*(Aq)\->search(
\&   undef,
\&   {
\&     select   => [\*(Aqcd.title\*(Aq],
\&     as       => [\*(Aqcd_title\*(Aq],
\&     prefetch => \*(Aqartist\*(Aq,
\&   }
\& );
.Ve
.PP
The \*(L"select\*(R" becomes: \f(CW\*(Aqcd.title\*(Aq, \*(Aqartist.*\*(Aq\fR and the \*(L"as\*(R"
becomes: \f(CW\*(Aqcd_title\*(Aq, \*(Aqartist.*\*(Aq\fR.
.PP
\fI\s-1CAVEATS\s0\fR
.IX Subsection "CAVEATS"
.PP
Prefetch does a lot of deep magic. As such, it may not behave exactly
as you might expect.
.IP "\(bu" 4
Prefetch uses the \*(L"cache\*(R" to populate the prefetched relationships. This
may or may not be what you want.
.IP "\(bu" 4
If you specify a condition on a prefetched relationship, \s-1ONLY\s0 those
rows that match the prefetched condition will be fetched into that relationship.
This means that adding prefetch to a \fIsearch()\fR \fBmay alter\fR what is returned by
traversing a relationship. So, if you have \f(CW\*(C`Artist\->has_many(CDs)\*(C'\fR and you do
.Sp
.Vb 5
\&  my $artist_rs = $schema\->resultset(\*(AqArtist\*(Aq)\->search({
\&      \*(Aqcds.year\*(Aq => 2008,
\&  }, {
\&      join => \*(Aqcds\*(Aq,
\&  });
\&
\&  my $count = $artist_rs\->first\->cds\->count;
\&
\&  my $artist_rs_prefetch = $artist_rs\->search( {}, { prefetch => \*(Aqcds\*(Aq } );
\&
\&  my $prefetch_count = $artist_rs_prefetch\->first\->cds\->count;
\&
\&  cmp_ok( $count, \*(Aq==\*(Aq, $prefetch_count, "Counts should be the same" );
.Ve
.Sp
that \fIcmp_ok()\fR may or may not pass depending on the datasets involved. This
behavior may or may not survive the 0.09 transition.
.SS "page"
.IX Subsection "page"
.ie n .IP "Value: $page" 4
.el .IP "Value: \f(CW$page\fR" 4
.IX Item "Value: $page"
.PP
Makes the resultset paged and specifies the page to retrieve. Effectively
identical to creating a non-pages resultset and then calling \->page($page)
on it.
.PP
If \*(L"rows\*(R" attribute is not specified it defaults to 10 rows per page.
.PP
When you have a paged resultset, \*(L"count\*(R" will only return the number
of rows in the page. To get the total, use the \*(L"pager\*(R" and call
\&\f(CW\*(C`total_entries\*(C'\fR on it.
.SS "rows"
.IX Subsection "rows"
.ie n .IP "Value: $rows" 4
.el .IP "Value: \f(CW$rows\fR" 4
.IX Item "Value: $rows"
.PP
Specifies the maximum number of rows for direct retrieval or the number of
rows per page if the page attribute or method is used.
.SS "offset"
.IX Subsection "offset"
.ie n .IP "Value: $offset" 4
.el .IP "Value: \f(CW$offset\fR" 4
.IX Item "Value: $offset"
.PP
Specifies the (zero-based) row number for the  first row to be returned, or the
of the first row of the first page if paging is used.
.SS "group_by"
.IX Subsection "group_by"
.IP "Value: \e@columns" 4
.IX Item "Value: @columns"
.PP
A arrayref of columns to group by. Can include columns of joined tables.
.PP
.Vb 1
\&  group_by => [qw/ column1 column2 ... /]
.Ve
.SS "having"
.IX Subsection "having"
.ie n .IP "Value: $condition" 4
.el .IP "Value: \f(CW$condition\fR" 4
.IX Item "Value: $condition"
.PP
\&\s-1HAVING\s0 is a select statement attribute that is applied between \s-1GROUP\s0 \s-1BY\s0 and
\&\s-1ORDER\s0 \s-1BY\s0. It is applied to the after the grouping calculations have been
done.
.PP
.Vb 1
\&  having => { \*(Aqcount_employee\*(Aq => { \*(Aq>=\*(Aq, 100 } }
.Ve
.PP
or with an in-place function in which case literal \s-1SQL\s0 is required:
.PP
.Vb 1
\&  having => \e[ \*(Aqcount(employee) >= ?\*(Aq, [ count => 100 ] ]
.Ve
.SS "distinct"
.IX Subsection "distinct"
.IP "Value: (0 | 1)" 4
.IX Item "Value: (0 | 1)"
.PP
Set to 1 to group by all columns. If the resultset already has a group_by
attribute, this setting is ignored and an appropriate warning is issued.
.SS "where"
.IX Subsection "where"
.RS 4
Adds to the \s-1WHERE\s0 clause.
.Sp
.Vb 2
\&  # only return rows WHERE deleted IS NULL for all searches
\&  _\|_PACKAGE_\|_\->resultset_attributes({ where => { deleted => undef } }); )
.Ve
.Sp
Can be overridden by passing \f(CW\*(C`{ where => undef }\*(C'\fR as an attribute
to a resultset.
.RE
.SS "cache"
.IX Subsection "cache"
Set to 1 to cache search results. This prevents extra \s-1SQL\s0 queries if you
revisit rows in your ResultSet:
.PP
.Vb 1
\&  my $resultset = $schema\->resultset(\*(AqArtist\*(Aq)\->search( undef, { cache => 1 } );
\&
\&  while( my $artist = $resultset\->next ) {
\&    ... do stuff ...
\&  }
\&
\&  $rs\->first; # without cache, this would issue a query
.Ve
.PP
By default, searches are not cached.
.PP
For more examples of using these attributes, see
DBIx::Class::Manual::Cookbook.
.SS "for"
.IX Subsection "for"
.IP "Value: ( 'update' | 'shared' )" 4
.IX Item "Value: ( 'update' | 'shared' )"
.PP
Set to 'update' for a \s-1SELECT\s0 ... \s-1FOR\s0 \s-1UPDATE\s0 or 'shared' for a \s-1SELECT\s0
\&... \s-1FOR\s0 \s-1SHARED\s0.

.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::TreeBuilder 3"
.TH HTML::TreeBuilder 3 "2013-08-25" "perl v5.12.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::TreeBuilder \- Parser that builds a HTML syntax tree
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  foreach my $file_name (@ARGV) {
\&    my $tree = HTML::TreeBuilder\->new; # empty tree
\&    $tree\->parse_file($file_name);
\&    print "Hey, here\*(Aqs a dump of the parse tree of $file_name:\en";
\&    $tree\->dump; # a method we inherit from HTML::Element
\&    print "And here it is, bizarrely rerendered as HTML:\en",
\&      $tree\->as_HTML, "\en";
\&    
\&    # Now that we\*(Aqre done with it, we must destroy it.
\&    $tree = $tree\->delete;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
(This class is part of the HTML::Tree dist.)
.PP
This class is for \s-1HTML\s0 syntax trees that get built out of \s-1HTML\s0
source.  The way to use it is to:
.PP
1. start a new (empty) HTML::TreeBuilder object,
.PP
2. then use one of the methods from HTML::Parser (presumably with
\&\f(CW$tree\fR\->parse_file($filename) for files, or with
\&\f(CW$tree\fR\->parse($document_content) and \f(CW$tree\fR\->eof if you've got
the content in a string) to parse the \s-1HTML\s0
document into the tree \f(CW$tree\fR.
.PP
(You can combine steps 1 and 2 with the \*(L"new_from_file\*(R" or
\&\*(L"new_from_content\*(R" methods.)
.PP
2b. call \f(CW$root\fR\->\fIelementify()\fR if you want.
.PP
3. do whatever you need to do with the syntax tree, presumably
involving traversing it looking for some bit of information in it,
.PP
4. and finally, when you're done with the tree, call \f(CW$tree\fR\->\fIdelete()\fR to
erase the contents of the tree from memory.  This kind of thing
usually isn't necessary with most Perl objects, but it's necessary for
TreeBuilder objects.  See HTML::Element for a more verbose
explanation of why this is the case.
.SH "METHODS AND ATTRIBUTES"
.IX Header "METHODS AND ATTRIBUTES"
Objects of this class inherit the methods of both HTML::Parser and
HTML::Element.  The methods inherited from HTML::Parser are used for
building the \s-1HTML\s0 tree, and the methods inherited from HTML::Element
are what you use to scrutinize the tree.  Besides this
(HTML::TreeBuilder) documentation, you must also carefully read the
HTML::Element documentation, and also skim the HTML::Parser
documentation \*(-- probably only its parse and parse_file methods are of
interest.
.PP
Most of the following methods native to HTML::TreeBuilder control how
parsing takes place; they should be set \fIbefore\fR you try parsing into
the given object.  You can set the attributes by passing a \s-1TRUE\s0 or
\&\s-1FALSE\s0 value as argument.  E.g., \f(CW$root\fR\->implicit_tags returns the current
setting for the implicit_tags option, \f(CW$root\fR\->\fIimplicit_tags\fR\|(1) turns that
option on, and \f(CW$root\fR\->\fIimplicit_tags\fR\|(0) turns it off.
.ie n .IP "$root = HTML::TreeBuilder\->new_from_file(...)" 4
.el .IP "\f(CW$root\fR = HTML::TreeBuilder\->new_from_file(...)" 4
.IX Item "$root = HTML::TreeBuilder->new_from_file(...)"
This \*(L"shortcut\*(R" constructor merely combines constructing a new object
(with the \*(L"new\*(R" method, below), and calling \f(CW$new\fR\->parse_file(...) on
it.  Returns the new object.  Note that this provides no way of
setting any parse options like store_comments (for that, call new, and
then set options, before calling parse_file).  See the notes (below)
on parameters to parse_file.
.ie n .IP "$root = HTML::TreeBuilder\->new_from_content(...)" 4
.el .IP "\f(CW$root\fR = HTML::TreeBuilder\->new_from_content(...)" 4
.IX Item "$root = HTML::TreeBuilder->new_from_content(...)"
This \*(L"shortcut\*(R" constructor merely combines constructing a new object
(with the \*(L"new\*(R" method, below), and calling for(...){$new\->parse($_)}
and \f(CW$new\fR\->eof on it.  Returns the new object.  Note that this provides
no way of setting any parse options like store_comments (for that,
call new, and then set options, before calling parse_file).  Example
usages: HTML::TreeBuilder\->new_from_content(@lines), or
HTML::TreeBuilder\->new_from_content($content)
.ie n .IP "$root = HTML::TreeBuilder\->\fInew()\fR" 4
.el .IP "\f(CW$root\fR = HTML::TreeBuilder\->\fInew()\fR" 4
.IX Item "$root = HTML::TreeBuilder->new()"
This creates a new HTML::TreeBuilder object.  This method takes no
attributes.
.ie n .IP "$root\->parse_file(...)" 4
.el .IP "\f(CW$root\fR\->parse_file(...)" 4
.IX Item "$root->parse_file(...)"
[An important method inherited from HTML::Parser, which
see.  Current versions of HTML::Parser can take a filespec, or a
filehandle object, like *FOO, or some object from class IO::Handle,
IO::File, IO::Socket) or the like.
I think you should check that a given file exists \fIbefore\fR calling 
\&\f(CW$root\fR\->parse_file($filespec).]
.ie n .IP "$root\->parse(...)" 4
.el .IP "\f(CW$root\fR\->parse(...)" 4
.IX Item "$root->parse(...)"
[A important method inherited from HTML::Parser, which
see.  See the note below for \f(CW$root\fR\->\fIeof()\fR.]
.ie n .IP "$root\->\fIeof()\fR" 4
.el .IP "\f(CW$root\fR\->\fIeof()\fR" 4
.IX Item "$root->eof()"
This signals that you're finished parsing content into this tree; this
runs various kinds of crucial cleanup on the tree.  This is called
\&\fIfor you\fR when you call \f(CW$root\fR\->parse_file(...), but not when
you call \f(CW$root\fR\->parse(...).  So if you call
\&\f(CW$root\fR\->parse(...), then you \fImust\fR call \f(CW$root\fR\->\fIeof()\fR
once you've finished feeding all the chunks to parse(...), and
before you actually start doing anything else with the tree in \f(CW$root\fR.
.ie n .IP """$root\->parse_content(...)""" 4
.el .IP "\f(CW$root\->parse_content(...)\fR" 4
.IX Item "$root->parse_content(...)"
Basically a happly alias for \f(CW\*(C`$root\->parse(...); $root\->eof\*(C'\fR.
Takes the exact same arguments as \f(CW\*(C`$root\->parse()\*(C'\fR.
.ie n .IP "$root\->\fIdelete()\fR" 4
.el .IP "\f(CW$root\fR\->\fIdelete()\fR" 4
.IX Item "$root->delete()"
[An important method inherited from HTML::Element, which
see.]
.ie n .IP "$root\->\fIelementify()\fR" 4
.el .IP "\f(CW$root\fR\->\fIelementify()\fR" 4
.IX Item "$root->elementify()"
This changes the class of the object in \f(CW$root\fR from
HTML::TreeBuilder to the class used for all the rest of the elements
in that tree (generally HTML::Element).  Returns \f(CW$root\fR.
.Sp
For most purposes, this is unnecessary, but if you call this after
(after!!)
you've finished building a tree, then it keeps you from accidentally
trying to call anything but HTML::Element methods on it.  (I.e., if
you accidentally call \f(CW\*(C`$root\->parse_file(...)\*(C'\fR on the
already-complete and elementified tree, then instead of charging ahead
and \fIwreaking havoc\fR, it'll throw a fatal error \*(-- since \f(CW$root\fR is
now an object just of class HTML::Element which has no \f(CW\*(C`parse_file\*(C'\fR
method.
.Sp
Note that elementify currently deletes all the private attributes of
\&\f(CW$root\fR except for \*(L"_tag\*(R", \*(L"_parent\*(R", \*(L"_content\*(R", \*(L"_pos\*(R", and
\&\*(L"_implicit\*(R".  If anyone requests that I change this to leave in yet
more private attributes, I might do so, in future versions.
.ie n .IP "@nodes = $root\->\fIguts()\fR" 4
.el .IP "\f(CW@nodes\fR = \f(CW$root\fR\->\fIguts()\fR" 4
.IX Item "@nodes = $root->guts()"
.PD 0
.ie n .IP "$parent_for_nodes = $root\->\fIguts()\fR" 4
.el .IP "\f(CW$parent_for_nodes\fR = \f(CW$root\fR\->\fIguts()\fR" 4
.IX Item "$parent_for_nodes = $root->guts()"
.PD
In list context (as in the first case), this method returns the topmost
non-implicit nodes in a tree.  This is useful when you're parsing \s-1HTML\s0
code that you know doesn't expect an \s-1HTML\s0 document, but instead just
a fragment of an \s-1HTML\s0 document.  For example, if you wanted the parse
tree for a file consisting of just this:
.Sp
.Vb 1
\&  <li>I like pie!
.Ve
.Sp
Then you would get that with \f(CW\*(C`@nodes = $root\->guts();\*(C'\fR.
It so happens that in this case, \f(CW@nodes\fR will contain just one
element object, representing the \*(L"li\*(R" node (with \*(L"I like pie!\*(R" being
its text child node).  However, consider if you were parsing this:
.Sp
.Vb 1
\&  <hr>Hooboy!<hr>
.Ve
.Sp
In that case, \f(CW\*(C`$root\->guts()\*(C'\fR would return three items:
an element object for the first \*(L"hr\*(R", a text string \*(L"Hooboy!\*(R", and
another \*(L"hr\*(R" element object.
.Sp
For cases where you want definitely one element (so you can treat it as
a \*(L"document fragment\*(R", roughly speaking), call \f(CW\*(C`guts()\*(C'\fR in scalar
context, as in \f(CW\*(C`$parent_for_nodes = $root\->guts()\*(C'\fR. That works like
\&\f(CW\*(C`guts()\*(C'\fR in list context; in fact, \f(CW\*(C`guts()\*(C'\fR in list context would
have returned exactly one value, and if it would have been an object (as
opposed to a text string), then that's what \f(CW\*(C`guts\*(C'\fR in scalar context
will return.  Otherwise, if \f(CW\*(C`guts()\*(C'\fR in list context would have returned
no values at all, then \f(CW\*(C`guts()\*(C'\fR in scalar context returns undef.  In
all other cases, \f(CW\*(C`guts()\*(C'\fR in scalar context returns an implicit 'div'
element node, with children consisting of whatever nodes \f(CW\*(C`guts()\*(C'\fR
in list context would have returned.  Note that that may detach those
nodes from \f(CW$root\fR's tree.
.ie n .IP "@nodes = $root\->\fIdisembowel()\fR" 4
.el .IP "\f(CW@nodes\fR = \f(CW$root\fR\->\fIdisembowel()\fR" 4
.IX Item "@nodes = $root->disembowel()"
.PD 0
.ie n .IP "$parent_for_nodes = $root\->\fIdisembowel()\fR" 4
.el .IP "\f(CW$parent_for_nodes\fR = \f(CW$root\fR\->\fIdisembowel()\fR" 4
.IX Item "$parent_for_nodes = $root->disembowel()"
.PD
The \f(CW\*(C`disembowel()\*(C'\fR method works just like the \f(CW\*(C`guts()\*(C'\fR method, except
that disembowel definitively destroys the tree above the nodes that
are returned.  Usually when you want the guts from a tree, you're just
going to toss out the rest of the tree anyway, so this saves you the
bother.  (Remember, \*(L"disembowel\*(R" means \*(L"remove the guts from\*(R".)
.ie n .IP "$root\->implicit_tags(value)" 4
.el .IP "\f(CW$root\fR\->implicit_tags(value)" 4
.IX Item "$root->implicit_tags(value)"
Setting this attribute to true will instruct the parser to try to
deduce implicit elements and implicit end tags.  If it is false you
get a parse tree that just reflects the text as it stands, which is
unlikely to be useful for anything but quick and dirty parsing.
(In fact, I'd be curious to hear from anyone who finds it useful to
have implicit_tags set to false.)
Default is true.
.Sp
Implicit elements have the \fIimplicit()\fR attribute set.
.ie n .IP "$root\->implicit_body_p_tag(value)" 4
.el .IP "\f(CW$root\fR\->implicit_body_p_tag(value)" 4
.IX Item "$root->implicit_body_p_tag(value)"
This controls an aspect of implicit element behavior, if implicit_tags
is on:  If a text element (\s-1PCDATA\s0) or a phrasal element (such as
\&\*(L"<em>\*(R") is to be inserted under \*(L"<body>\*(R", two things
can happen: if implicit_body_p_tag is true, it's placed under a new,
implicit \*(L"<p>\*(R" tag.  (Past DTDs suggested this was the only
correct behavior, and this is how past versions of this module
behaved.)  But if implicit_body_p_tag is false, nothing is implicated
\&\*(-- the \s-1PCDATA\s0 or phrasal element is simply placed under
\&\*(L"<body>\*(R".  Default is false.
.ie n .IP "$root\->no_expand_entities(value)" 4
.el .IP "\f(CW$root\fR\->no_expand_entities(value)" 4
.IX Item "$root->no_expand_entities(value)"
This attribute controls whether entities are decoded during the initial
parse of the source. Enable this if you don't want entities decoded to
their character value. e.g. '&amp;' is decoded to '&' by default, but
will be unchanged if this is enabled.
Default is false (entities will be decoded.)
.ie n .IP "$root\->ignore_unknown(value)" 4
.el .IP "\f(CW$root\fR\->ignore_unknown(value)" 4
.IX Item "$root->ignore_unknown(value)"
This attribute controls whether unknown tags should be represented as
elements in the parse tree, or whether they should be ignored. 
Default is true (to ignore unknown tags.)
.ie n .IP "$root\->ignore_text(value)" 4
.el .IP "\f(CW$root\fR\->ignore_text(value)" 4
.IX Item "$root->ignore_text(value)"
Do not represent the text content of elements.  This saves space if
all you want is to examine the structure of the document.  Default is
false.
.ie n .IP "$root\->ignore_ignorable_whitespace(value)" 4
.el .IP "\f(CW$root\fR\->ignore_ignorable_whitespace(value)" 4
.IX Item "$root->ignore_ignorable_whitespace(value)"
If set to true, TreeBuilder will try to avoid
creating ignorable whitespace text nodes in the tree.  Default is
true.  (In fact, I'd be interested in hearing if there's ever a case
where you need this off, or where leaving it on leads to incorrect
behavior.)
.ie n .IP "$root\->no_space_compacting(value)" 4
.el .IP "\f(CW$root\fR\->no_space_compacting(value)" 4
.IX Item "$root->no_space_compacting(value)"
This determines whether TreeBuilder compacts all whitespace strings
in the document (well, outside of \s-1PRE\s0 or \s-1TEXTAREA\s0 elements), or
leaves them alone.  Normally (default, value of 0), each string of
contiguous whitespace in the document is turned into a single space.
But that's not done if no_space_compacting is set to 1.
.Sp
Setting no_space_compacting to 1 might be useful if you want
to read in a tree just to make some minor changes to it before
writing it back out.
.Sp
This method is experimental.  If you use it, be sure to report
any problems you might have with it.
.ie n .IP "$root\->p_strict(value)" 4
.el .IP "\f(CW$root\fR\->p_strict(value)" 4
.IX Item "$root->p_strict(value)"
If set to true (and it defaults to false), TreeBuilder will take a
narrower than normal view of what can be under a \*(L"p\*(R" element; if it sees
a non-phrasal element about to be inserted under a \*(L"p\*(R", it will close that
\&\*(L"p\*(R".  Otherwise it will close p elements only for other \*(L"p\*(R"'s, headings,
and \*(L"form\*(R" (although the latter may be removed in future versions).
.Sp
For example, when going thru this snippet of code,
.Sp
.Vb 2
\&  <p>stuff
\&  <ul>
.Ve
.Sp
TreeBuilder will normally (with \f(CW\*(C`p_strict\*(C'\fR false) put the \*(L"ul\*(R" element
under the \*(L"p\*(R" element.  However, with \f(CW\*(C`p_strict\*(C'\fR set to true, it will
close the \*(L"p\*(R" first.
.Sp
In theory, there should be strictness options like this for other/all
elements besides just \*(L"p\*(R"; but I treat this as a special case simply
because of the fact that \*(L"p\*(R" occurs so frequently and its end-tag is
omitted so often; and also because application of strictness rules
at parse-time across all elements often makes tiny errors in \s-1HTML\s0
coding produce drastically bad parse-trees, in my experience.
.Sp
If you find that you wish you had an option like this to enforce
content-models on all elements, then I suggest that what you want is
content-model checking as a stage after TreeBuilder has finished
parsing.
.ie n .IP "$root\->store_comments(value)" 4
.el .IP "\f(CW$root\fR\->store_comments(value)" 4
.IX Item "$root->store_comments(value)"
This determines whether TreeBuilder will normally store comments found
while parsing content into \f(CW$root\fR.  Currently, this is off by default.
.ie n .IP "$root\->store_declarations(value)" 4
.el .IP "\f(CW$root\fR\->store_declarations(value)" 4
.IX Item "$root->store_declarations(value)"
This determines whether TreeBuilder will normally store markup
declarations found while parsing content into \f(CW$root\fR.  This is on
by default.
.ie n .IP "$root\->store_pis(value)" 4
.el .IP "\f(CW$root\fR\->store_pis(value)" 4
.IX Item "$root->store_pis(value)"
This determines whether TreeBuilder will normally store processing
instructions found while parsing content into \f(CW$root\fR \*(-- assuming a
recent version of HTML::Parser (old versions won't parse PIs
correctly).  Currently, this is off (false) by default.
.Sp
It is somewhat of a known bug (to be fixed one of these days, if
anyone needs it?) that PIs in the preamble (before the \*(L"html\*(R"
start-tag) end up actually \fIunder\fR the \*(L"html\*(R" element.
.ie n .IP "$root\->warn(value)" 4
.el .IP "\f(CW$root\fR\->warn(value)" 4
.IX Item "$root->warn(value)"
This determines whether syntax errors during parsing should generate
warnings, emitted via Perl's \f(CW\*(C`warn\*(C'\fR function.
.Sp
This is off (false) by default.
.ie n .IP "$h\->element_class" 4
.el .IP "\f(CW$h\fR\->element_class" 4
.IX Item "$h->element_class"
This method returns the class which will be used for new elements.  It
defaults to HTML::Element, but can be overridden by subclassing or esoteric
means best left to those will will read the source and then not complain when
those esoteric means change.  (Just subclass.)
.IP "\s-1DEBUG\s0" 4
.IX Item "DEBUG"
Are we in Debug mode?
.IP "comment" 4
.IX Item "comment"
Accept a \*(L"here's a comment\*(R" signal from HTML::Parser.
.IP "declaration" 4
.IX Item "declaration"
Accept a \*(L"here's a markup declaration\*(R" signal from HTML::Parser.
.IP "done" 4
.IX Item "done"
\&\s-1TODO:\s0 document
.IP "end" 4
.IX Item "end"
Either: Acccept an end-tag signal from HTML::Parser
Or: Method for closing currently open elements in some fairly complex
way, as used by other methods in this class.
.Sp
\&\s-1TODO:\s0 Why is this hidden?
.IP "process" 4
.IX Item "process"
Accept a \*(L"here's a \s-1PI\s0\*(R" signal from HTML::Parser.
.IP "start" 4
.IX Item "start"
Accept a signal from HTML::Parser for start-tags.
.Sp
\&\s-1TODO:\s0 Why is this hidden?
.IP "stunt" 4
.IX Item "stunt"
\&\s-1TODO:\s0 document
.IP "stunted" 4
.IX Item "stunted"
\&\s-1TODO:\s0 document
.IP "text" 4
.IX Item "text"
Accept a \*(L"here's a text token\*(R" signal from HTML::Parser.
.Sp
\&\s-1TODO:\s0 Why is this hidden?
.IP "tighten_up" 4
.IX Item "tighten_up"
Legacy
.Sp
Redirects to HTML::Element:: delete_ignorable_whitespace
.IP "warning" 4
.IX Item "warning"
Wrapper for CORE::warn
.Sp
\&\s-1TODO:\s0 why not just use carp?
.SH "HTML AND ITS DISCONTENTS"
.IX Header "HTML AND ITS DISCONTENTS"
\&\s-1HTML\s0 is rather harder to parse than people who write it generally
suspect.
.PP
Here's the problem: \s-1HTML\s0 is a kind of \s-1SGML\s0 that permits \*(L"minimization\*(R"
and \*(L"implication\*(R".  In short, this means that you don't have to close
every tag you open (because the opening of a subsequent tag may
implicitly close it), and if you use a tag that can't occur in the
context you seem to using it in, under certain conditions the parser
will be able to realize you mean to leave the current context and
enter the new one, that being the only one that your code could
correctly be interpreted in.
.PP
Now, this would all work flawlessly and unproblematically if: 1) all
the rules that both prescribe and describe \s-1HTML\s0 were (and had been)
clearly set out, and 2) everyone was aware of these rules and wrote
their code in compliance to them.
.PP
However, it didn't happen that way, and so most \s-1HTML\s0 pages are
difficult if not impossible to correctly parse with nearly any set of
straightforward \s-1SGML\s0 rules.  That's why the internals of
HTML::TreeBuilder consist of lots and lots of special cases \*(-- instead
of being just a generic \s-1SGML\s0 parser with \s-1HTML\s0 \s-1DTD\s0 rules plugged in.
.SH "TRANSLATIONS?"
.IX Header "TRANSLATIONS?"
The techniques that HTML::TreeBuilder uses to perform what I consider
very robust parses on everyday code are not things that can work only
in Perl.  To date, the algorithms at the center of HTML::TreeBuilder
have been implemented only in Perl, as far as I know; and I don't
foresee getting around to implementing them in any other language any
time soon.
.PP
If, however, anyone is looking for a semester project for an applied
programming class (or if they merely enjoy \fIextra-curricular\fR
masochism), they might do well to see about choosing as a topic the
implementation/adaptation of these routines to any other interesting
programming language that you feel currently suffers from a lack of
robust HTML-parsing.  I welcome correspondence on this subject, and
point out that one can learn a great deal about languages by trying to
translate between them, and then comparing the result.
.PP
The HTML::TreeBuilder source may seem long and complex, but it is
rather well commented, and symbol names are generally
self-explanatory.  (You are encouraged to read the Mozilla \s-1HTML\s0 parser
source for comparison.)  Some of the complexity comes from little-used
features, and some of it comes from having the \s-1HTML\s0 tokenizer
(HTML::Parser) being a separate module, requiring somewhat of a
different interface than you'd find in a combined tokenizer and
tree-builder.  But most of the length of the source comes from the fact
that it's essentially a long list of special cases, with lots and lots
of sanity-checking, and sanity-recovery \*(-- because, as Roseanne
Rosannadanna once said, "it's always \fIsomething\fR".
.PP
Users looking to compare several \s-1HTML\s0 parsers should look at the
source for Raggett's Tidy
(\f(CW\*(C`<http://www.w3.org/People/Raggett/tidy/>\*(C'\fR),
Mozilla
(\f(CW\*(C`<http://www.mozilla.org/>\*(C'\fR),
and possibly root around the browsers section of Yahoo
to find the various open-source ones
(\f(CW\*(C`<http://dir.yahoo.com/Computers_and_Internet/Software/Internet/World_Wide_Web/Browsers/>\*(C'\fR).
.SH "BUGS"
.IX Header "BUGS"
* Framesets seem to work correctly now.  Email me if you get a strange
parse from a document with framesets.
.PP
* Really bad \s-1HTML\s0 code will, often as not, make for a somewhat
objectionable parse tree.  Regrettable, but unavoidably true.
.PP
* If you're running with implicit_tags off (God help you!), consider
that \f(CW$tree\fR\->content_list probably contains the tree or grove from the
parse, and not \f(CW$tree\fR itself (which will, oddly enough, be an implicit
\&'html' element).  This seems counter-intuitive and problematic; but
seeing as how almost no \s-1HTML\s0 ever parses correctly with implicit_tags
off, this interface oddity seems the least of your problems.
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
When a document parses in a way different from how you think it
should, I ask that you report this to me as a bug.  The first thing
you should do is copy the document, trim out as much of it as you can
while still producing the bug in question, and \fIthen\fR email me that
mini-document \fIand\fR the code you're using to parse it, to the HTML::Tree
bug queue at \f(CW\*(C`bug\-html\-tree at rt.cpan.org\*(C'\fR.
.PP
Include a note as to how it 
parses (presumably including its \f(CW$tree\fR\->dump output), and then a
\&\fIcareful and clear\fR explanation of where you think the parser is
going astray, and how you would prefer that it work instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::Tree; HTML::Parser, HTML::Element, HTML::Tagset
.PP
HTML::DOMbo
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-1998 Gisle Aas, 1999\-2004 Sean M. Burke, 2005 Andy Lester,
2006 Pete Krawczyk, 2010 Jeff Fearn.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Current Author:
	Jeff Fearn \f(CW\*(C`<jfearn@cpan.org>\*(C'\fR.
.PP
Original HTML-Tree author:
	Gisle Aas.
.PP
Former Authors:
	Sean M. Burke.
	Andy Lester.
	Pete Krawczyk \f(CW\*(C`<petek@cpan.org>\*(C'\fR.

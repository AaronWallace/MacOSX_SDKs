.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLBOT 1"
.TH PERLBOT 1 "2012-11-03" "perl v5.12.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlbot \- Bag'o Object Tricks (the BOT)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The following collection of tricks and hints is intended to whet curious
appetites about such things as the use of instance variables and the
mechanics of object and class relationships.  The reader is encouraged to
consult relevant textbooks for discussion of Object Oriented definitions and
methodology.  This is not intended as a tutorial for object-oriented
programming or as a comprehensive guide to Perl's object oriented features,
nor should it be construed as a style guide.  If you're looking for tutorials,
be sure to read perlboot, perltoot, and perltooc.
.PP
The Perl motto still holds:  There's more than one way to do it.
.SH "OO SCALING TIPS"
.IX Header "OO SCALING TIPS"
.IP "1." 5
Do not attempt to verify the type of \f(CW$self\fR.  That'll break if the class is
inherited, when the type of \f(CW$self\fR is valid but its package isn't what you
expect.  See rule 5.
.IP "2." 5
If an object-oriented (\s-1OO\s0) or indirect-object (\s-1IO\s0) syntax was used, then the
object is probably the correct type and there's no need to become paranoid
about it.  Perl isn't a paranoid language anyway.  If people subvert the \s-1OO\s0
or \s-1IO\s0 syntax then they probably know what they're doing and you should let
them do it.  See rule 1.
.IP "3." 5
Use the two-argument form of \fIbless()\fR.  Let a subclass use your constructor.
See \*(L"\s-1INHERITING\s0 A \s-1CONSTRUCTOR\s0\*(R".
.IP "4." 5
The subclass is allowed to know things about its immediate superclass, the
superclass is allowed to know nothing about a subclass.
.IP "5." 5
Don't be trigger happy with inheritance.  A \*(L"using\*(R", \*(L"containing\*(R", or
\&\*(L"delegation\*(R" relationship (some sort of aggregation, at least) is often more
appropriate.  See \*(L"\s-1OBJECT\s0 \s-1RELATIONSHIPS\s0\*(R", \*(L"\s-1USING\s0 \s-1RELATIONSHIP\s0 \s-1WITH\s0 \s-1SDBM\s0\*(R",
and \*(L"\s-1DELEGATION\s0\*(R".
.IP "6." 5
The object is the namespace.  Make package globals accessible via the
object.  This will remove the guess work about the symbol's home package.
See \*(L"\s-1CLASS\s0 \s-1CONTEXT\s0 \s-1AND\s0 \s-1THE\s0 \s-1OBJECT\s0\*(R".
.IP "7." 5
\&\s-1IO\s0 syntax is certainly less noisy, but it is also prone to ambiguities that
can cause difficult-to-find bugs.  Allow people to use the sure-thing \s-1OO\s0
syntax, even if you don't like it.
.IP "8." 5
Do not use function-call syntax on a method.  You're going to be bitten
someday.  Someone might move that method into a superclass and your code
will be broken.  On top of that you're feeding the paranoia in rule 2.
.IP "9." 5
Don't assume you know the home package of a method.  You're making it
difficult for someone to override that method.  See \*(L"\s-1THINKING\s0 \s-1OF\s0 \s-1CODE\s0 \s-1REUSE\s0\*(R".
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
An anonymous array or anonymous hash can be used to hold instance
variables.  Named parameters are also demonstrated.
.PP
.Vb 1
\&        package Foo;
\&
\&        sub new {
\&                my $type = shift;
\&                my %params = @_;
\&                my $self = {};
\&                $self\->{\*(AqHigh\*(Aq} = $params{\*(AqHigh\*(Aq};
\&                $self\->{\*(AqLow\*(Aq}  = $params{\*(AqLow\*(Aq};
\&                bless $self, $type;
\&        }
\&
\&
\&        package Bar;
\&
\&        sub new {
\&                my $type = shift;
\&                my %params = @_;
\&                my $self = [];
\&                $self\->[0] = $params{\*(AqLeft\*(Aq};
\&                $self\->[1] = $params{\*(AqRight\*(Aq};
\&                bless $self, $type;
\&        }
\&
\&        package main;
\&
\&        $a = Foo\->new( \*(AqHigh\*(Aq => 42, \*(AqLow\*(Aq => 11 );
\&        print "High=$a\->{\*(AqHigh\*(Aq}\en";
\&        print "Low=$a\->{\*(AqLow\*(Aq}\en";
\&
\&        $b = Bar\->new( \*(AqLeft\*(Aq => 78, \*(AqRight\*(Aq => 40 );
\&        print "Left=$b\->[0]\en";
\&        print "Right=$b\->[1]\en";
.Ve
.SH "SCALAR INSTANCE VARIABLES"
.IX Header "SCALAR INSTANCE VARIABLES"
An anonymous scalar can be used when only one instance variable is needed.
.PP
.Vb 1
\&        package Foo;
\&
\&        sub new {
\&                my $type = shift;
\&                my $self;
\&                $self = shift;
\&                bless \e$self, $type;
\&        }
\&
\&        package main;
\&
\&        $a = Foo\->new( 42 );
\&        print "a=$$a\en";
.Ve
.SH "INSTANCE VARIABLE INHERITANCE"
.IX Header "INSTANCE VARIABLE INHERITANCE"
This example demonstrates how one might inherit instance variables from a
superclass for inclusion in the new class.  This requires calling the
superclass's constructor and adding one's own instance variables to the new
object.
.PP
.Vb 1
\&        package Bar;
\&
\&        sub new {
\&                my $type = shift;
\&                my $self = {};
\&                $self\->{\*(Aqbuz\*(Aq} = 42;
\&                bless $self, $type;
\&        }
\&
\&        package Foo;
\&        @ISA = qw( Bar );
\&
\&        sub new {
\&                my $type = shift;
\&                my $self = Bar\->new;
\&                $self\->{\*(Aqbiz\*(Aq} = 11;
\&                bless $self, $type;
\&        }
\&
\&        package main;
\&
\&        $a = Foo\->new;
\&        print "buz = ", $a\->{\*(Aqbuz\*(Aq}, "\en";
\&        print "biz = ", $a\->{\*(Aqbiz\*(Aq}, "\en";
.Ve
.SH "OBJECT RELATIONSHIPS"
.IX Header "OBJECT RELATIONSHIPS"
The following demonstrates how one might implement \*(L"containing\*(R" and \*(L"using\*(R"
relationships between objects.
.PP
.Vb 1
\&        package Bar;
\&
\&        sub new {
\&                my $type = shift;
\&                my $self = {};
\&                $self\->{\*(Aqbuz\*(Aq} = 42;
\&                bless $self, $type;
\&        }
\&
\&        package Foo;
\&
\&        sub new {
\&                my $type = shift;
\&                my $self = {};
\&                $self\->{\*(AqBar\*(Aq} = Bar\->new;
\&                $self\->{\*(Aqbiz\*(Aq} = 11;
\&                bless $self, $type;
\&        }
\&
\&        package main;
\&
\&        $a = Foo\->new;
\&        print "buz = ", $a\->{\*(AqBar\*(Aq}\->{\*(Aqbuz\*(Aq}, "\en";
\&        print "biz = ", $a\->{\*(Aqbiz\*(Aq}, "\en";
.Ve
.SH "OVERRIDING SUPERCLASS METHODS"
.IX Header "OVERRIDING SUPERCLASS METHODS"
The following example demonstrates how to override a superclass method and
then call the overridden method.  The \fB\s-1SUPER\s0\fR pseudo-class allows the
programmer to call an overridden superclass method without actually knowing
where that method is defined.
.PP
.Vb 2
\&        package Buz;
\&        sub goo { print "here\*(Aqs the goo\en" }
\&
\&        package Bar; @ISA = qw( Buz );
\&        sub google { print "google here\en" }
\&
\&        package Baz;
\&        sub mumble { print "mumbling\en" }
\&
\&        package Foo;
\&        @ISA = qw( Bar Baz );
\&
\&        sub new {
\&                my $type = shift;
\&                bless [], $type;
\&        }
\&        sub grr { print "grumble\en" }
\&        sub goo {
\&                my $self = shift;
\&                $self\->SUPER::goo();
\&        }
\&        sub mumble {
\&                my $self = shift;
\&                $self\->SUPER::mumble();
\&        }
\&        sub google {
\&                my $self = shift;
\&                $self\->SUPER::google();
\&        }
\&
\&        package main;
\&
\&        $foo = Foo\->new;
\&        $foo\->mumble;
\&        $foo\->grr;
\&        $foo\->goo;
\&        $foo\->google;
.Ve
.PP
Note that \f(CW\*(C`SUPER\*(C'\fR refers to the superclasses of the current package
(\f(CW\*(C`Foo\*(C'\fR), not to the superclasses of \f(CW$self\fR.
.SH "USING RELATIONSHIP WITH SDBM"
.IX Header "USING RELATIONSHIP WITH SDBM"
This example demonstrates an interface for the \s-1SDBM\s0 class.  This creates a
\&\*(L"using\*(R" relationship between the \s-1SDBM\s0 class and the new class Mydbm.
.PP
.Vb 1
\&        package Mydbm;
\&
\&        require SDBM_File;
\&        require Tie::Hash;
\&        @ISA = qw( Tie::Hash );
\&
\&        sub TIEHASH {
\&            my $type = shift;
\&            my $ref  = SDBM_File\->new(@_);
\&            bless {\*(Aqdbm\*(Aq => $ref}, $type;
\&        }
\&        sub FETCH {
\&            my $self = shift;
\&            my $ref  = $self\->{\*(Aqdbm\*(Aq};
\&            $ref\->FETCH(@_);
\&        }
\&        sub STORE {
\&            my $self = shift;
\&            if (defined $_[0]){
\&                my $ref = $self\->{\*(Aqdbm\*(Aq};
\&                $ref\->STORE(@_);
\&            } else {
\&                die "Cannot STORE an undefined key in Mydbm\en";
\&            }
\&        }
\&
\&        package main;
\&        use Fcntl qw( O_RDWR O_CREAT );
\&
\&        tie %foo, "Mydbm", "Sdbm", O_RDWR|O_CREAT, 0640;
\&        $foo{\*(Aqbar\*(Aq} = 123;
\&        print "foo\-bar = $foo{\*(Aqbar\*(Aq}\en";
\&
\&        tie %bar, "Mydbm", "Sdbm2", O_RDWR|O_CREAT, 0640;
\&        $bar{\*(AqCathy\*(Aq} = 456;
\&        print "bar\-Cathy = $bar{\*(AqCathy\*(Aq}\en";
.Ve
.SH "THINKING OF CODE REUSE"
.IX Header "THINKING OF CODE REUSE"
One strength of Object-Oriented languages is the ease with which old code
can use new code.  The following examples will demonstrate first how one can
hinder code reuse and then how one can promote code reuse.
.PP
This first example illustrates a class which uses a fully-qualified method
call to access the \*(L"private\*(R" method \s-1\fIBAZ\s0()\fR.  The second example will show
that it is impossible to override the \s-1\fIBAZ\s0()\fR method.
.PP
.Vb 1
\&        package FOO;
\&
\&        sub new {
\&                my $type = shift;
\&                bless {}, $type;
\&        }
\&        sub bar {
\&                my $self = shift;
\&                $self\->FOO::private::BAZ;
\&        }
\&
\&        package FOO::private;
\&
\&        sub BAZ {
\&                print "in BAZ\en";
\&        }
\&
\&        package main;
\&
\&        $a = FOO\->new;
\&        $a\->bar;
.Ve
.PP
Now we try to override the \s-1\fIBAZ\s0()\fR method.  We would like \fIFOO::bar()\fR to call
\&\s-1\fIGOOP::BAZ\s0()\fR, but this cannot happen because \fIFOO::bar()\fR explicitly calls
\&\fIFOO::private::BAZ()\fR.
.PP
.Vb 1
\&        package FOO;
\&
\&        sub new {
\&                my $type = shift;
\&                bless {}, $type;
\&        }
\&        sub bar {
\&                my $self = shift;
\&                $self\->FOO::private::BAZ;
\&        }
\&
\&        package FOO::private;
\&
\&        sub BAZ {
\&                print "in BAZ\en";
\&        }
\&
\&        package GOOP;
\&        @ISA = qw( FOO );
\&        sub new {
\&                my $type = shift;
\&                bless {}, $type;
\&        }
\&
\&        sub BAZ {
\&                print "in GOOP::BAZ\en";
\&        }
\&
\&        package main;
\&
\&        $a = GOOP\->new;
\&        $a\->bar;
.Ve
.PP
To create reusable code we must modify class \s-1FOO\s0, flattening class
FOO::private.  The next example shows a reusable class \s-1FOO\s0 which allows the
method \s-1\fIGOOP::BAZ\s0()\fR to be used in place of \s-1\fIFOO::BAZ\s0()\fR.
.PP
.Vb 1
\&        package FOO;
\&
\&        sub new {
\&                my $type = shift;
\&                bless {}, $type;
\&        }
\&        sub bar {
\&                my $self = shift;
\&                $self\->BAZ;
\&        }
\&
\&        sub BAZ {
\&                print "in BAZ\en";
\&        }
\&
\&        package GOOP;
\&        @ISA = qw( FOO );
\&
\&        sub new {
\&                my $type = shift;
\&                bless {}, $type;
\&        }
\&        sub BAZ {
\&                print "in GOOP::BAZ\en";
\&        }
\&
\&        package main;
\&
\&        $a = GOOP\->new;
\&        $a\->bar;
.Ve
.SH "CLASS CONTEXT AND THE OBJECT"
.IX Header "CLASS CONTEXT AND THE OBJECT"
Use the object to solve package and class context problems.  Everything a
method needs should be available via the object or should be passed as a
parameter to the method.
.PP
A class will sometimes have static or global data to be used by the
methods.  A subclass may want to override that data and replace it with new
data.  When this happens the superclass may not know how to find the new
copy of the data.
.PP
This problem can be solved by using the object to define the context of the
method.  Let the method look in the object for a reference to the data.  The
alternative is to force the method to go hunting for the data (\*(L"Is it in my
class, or in a subclass?  Which subclass?\*(R"), and this can be inconvenient
and will lead to hackery.  It is better just to let the object tell the
method where that data is located.
.PP
.Vb 1
\&        package Bar;
\&
\&        %fizzle = ( \*(AqPassword\*(Aq => \*(AqXYZZY\*(Aq );
\&
\&        sub new {
\&                my $type = shift;
\&                my $self = {};
\&                $self\->{\*(Aqfizzle\*(Aq} = \e%fizzle;
\&                bless $self, $type;
\&        }
\&
\&        sub enter {
\&                my $self = shift;
\&
\&                # Don\*(Aqt try to guess if we should use %Bar::fizzle
\&                # or %Foo::fizzle.  The object already knows which
\&                # we should use, so just ask it.
\&                #
\&                my $fizzle = $self\->{\*(Aqfizzle\*(Aq};
\&
\&                print "The word is ", $fizzle\->{\*(AqPassword\*(Aq}, "\en";
\&        }
\&
\&        package Foo;
\&        @ISA = qw( Bar );
\&
\&        %fizzle = ( \*(AqPassword\*(Aq => \*(AqRumple\*(Aq );
\&
\&        sub new {
\&                my $type = shift;
\&                my $self = Bar\->new;
\&                $self\->{\*(Aqfizzle\*(Aq} = \e%fizzle;
\&                bless $self, $type;
\&        }
\&
\&        package main;
\&
\&        $a = Bar\->new;
\&        $b = Foo\->new;
\&        $a\->enter;
\&        $b\->enter;
.Ve
.SH "INHERITING A CONSTRUCTOR"
.IX Header "INHERITING A CONSTRUCTOR"
An inheritable constructor should use the second form of \fIbless()\fR which allows
blessing directly into a specified class.  Notice in this example that the
object will be a \s-1BAR\s0 not a \s-1FOO\s0, even though the constructor is in class \s-1FOO\s0.
.PP
.Vb 1
\&        package FOO;
\&
\&        sub new {
\&                my $type = shift;
\&                my $self = {};
\&                bless $self, $type;
\&        }
\&
\&        sub baz {
\&                print "in FOO::baz()\en";
\&        }
\&
\&        package BAR;
\&        @ISA = qw(FOO);
\&
\&        sub baz {
\&                print "in BAR::baz()\en";
\&        }
\&
\&        package main;
\&
\&        $a = BAR\->new;
\&        $a\->baz;
.Ve
.SH "DELEGATION"
.IX Header "DELEGATION"
Some classes, such as SDBM_File, cannot be effectively subclassed because
they create foreign objects.  Such a class can be extended with some sort of
aggregation technique such as the \*(L"using\*(R" relationship mentioned earlier or
by delegation.
.PP
The following example demonstrates delegation using an \s-1\fIAUTOLOAD\s0()\fR function to
perform message-forwarding.  This will allow the Mydbm object to behave
exactly like an SDBM_File object.  The Mydbm class could now extend the
behavior by adding custom \s-1\fIFETCH\s0()\fR and \s-1\fISTORE\s0()\fR methods, if this is desired.
.PP
.Vb 1
\&        package Mydbm;
\&
\&        require SDBM_File;
\&        require Tie::Hash;
\&        @ISA = qw(Tie::Hash);
\&
\&        sub TIEHASH {
\&                my $type = shift;
\&                my $ref = SDBM_File\->new(@_);
\&                bless {\*(Aqdelegate\*(Aq => $ref};
\&        }
\&
\&        sub AUTOLOAD {
\&                my $self = shift;
\&
\&                # The Perl interpreter places the name of the
\&                # message in a variable called $AUTOLOAD.
\&
\&                # DESTROY messages should never be propagated.
\&                return if $AUTOLOAD =~ /::DESTROY$/;
\&
\&                # Remove the package name.
\&                $AUTOLOAD =~ s/^Mydbm:://;
\&
\&                # Pass the message to the delegate.
\&                $self\->{\*(Aqdelegate\*(Aq}\->$AUTOLOAD(@_);
\&        }
\&
\&        package main;
\&        use Fcntl qw( O_RDWR O_CREAT );
\&
\&        tie %foo, "Mydbm", "adbm", O_RDWR|O_CREAT, 0640;
\&        $foo{\*(Aqbar\*(Aq} = 123;
\&        print "foo\-bar = $foo{\*(Aqbar\*(Aq}\en";
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlboot, perltoot, perltooc.

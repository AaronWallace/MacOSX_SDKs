.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRECHARCLASS 1"
.TH PERLRECHARCLASS 1 "2012-11-03" "perl v5.12.5" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrecharclass \- Perl Regular Expression Character Classes
.IX Xref "character class"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The top level documentation about Perl regular expressions
is found in perlre.
.PP
This manual page discusses the syntax and use of character
classes in Perl regular expressions.
.PP
A character class is a way of denoting a set of characters
in such a way that one character of the set is matched.
It's important to remember that: matching a character class
consumes exactly one character in the source string. (The source
string is the string the regular expression is matched against.)
.PP
There are three types of character classes in Perl regular
expressions: the dot, backslash sequences, and the form enclosed in square
brackets.  Keep in mind, though, that often the term \*(L"character class\*(R" is used
to mean just the bracketed form.  Certainly, most Perl documentation does that.
.SS "The dot"
.IX Subsection "The dot"
The dot (or period), \f(CW\*(C`.\*(C'\fR is probably the most used, and certainly
the most well-known character class. By default, a dot matches any
character, except for the newline. The default can be changed to
add matching the newline by using the \fIsingle line\fR modifier: either
for the entire regular expression with the \f(CW\*(C`/s\*(C'\fR modifier, or
locally with \f(CW\*(C`(?s)\*(C'\fR.  (The experimental \f(CW\*(C`\eN\*(C'\fR backslash sequence, described
below, matches any character except newline without regard to the
\&\fIsingle line\fR modifier.)
.PP
Here are some examples:
.PP
.Vb 7
\& "a"  =~  /./       # Match
\& "."  =~  /./       # Match
\& ""   =~  /./       # No match (dot has to match a character)
\& "\en" =~  /./       # No match (dot does not match a newline)
\& "\en" =~  /./s      # Match (global \*(Aqsingle line\*(Aq modifier)
\& "\en" =~  /(?s:.)/  # Match (local \*(Aqsingle line\*(Aq modifier)
\& "ab" =~  /^.$/     # No match (dot matches one character)
.Ve
.SS "Backslash sequences"
.IX Xref "\\w \\W \\s \\S \\d \\D \\p \\P \\N \\v \\V \\h \\H word whitespace"
.IX Subsection "Backslash sequences"
A backslash sequence is a sequence of characters, the first one of which is a
backslash.  Perl ascribes special meaning to many such sequences, and some of
these are character classes.  That is, they match a single character each,
provided that the character belongs to the specific set of characters defined
by the sequence.
.PP
Here's a list of the backslash sequences that are character classes.  They
are discussed in more detail below.  (For the backslash sequences that aren't
character classes, see perlrebackslash.)
.PP
.Vb 10
\& \ed             Match a decimal digit character.
\& \eD             Match a non\-decimal\-digit character.
\& \ew             Match a "word" character.
\& \eW             Match a non\-"word" character.
\& \es             Match a whitespace character.
\& \eS             Match a non\-whitespace character.
\& \eh             Match a horizontal whitespace character.
\& \eH             Match a character that isn\*(Aqt horizontal whitespace.
\& \ev             Match a vertical whitespace character.
\& \eV             Match a character that isn\*(Aqt vertical whitespace.
\& \eN             Match a character that isn\*(Aqt a newline.  Experimental.
\& \epP, \ep{Prop}  Match a character that has the given Unicode property.
\& \ePP, \eP{Prop}  Match a character that doesn\*(Aqt have the Unicode property
.Ve
.PP
\fIDigits\fR
.IX Subsection "Digits"
.PP
\&\f(CW\*(C`\ed\*(C'\fR matches a single character that is considered to be a decimal \fIdigit\fR.
What is considered a decimal digit depends on the internal encoding of the
source string and the locale that is in effect. If the source string is in
\&\s-1UTF\-8\s0 format, \f(CW\*(C`\ed\*(C'\fR not only matches the digits '0' \- '9', but also Arabic,
Devanagari and digits from other languages. Otherwise, if there is a locale in
effect, it will match whatever characters the locale considers decimal digits.
Without a locale, \f(CW\*(C`\ed\*(C'\fR matches just the digits '0' to '9'.
See \*(L"Locale, \s-1EBCDIC\s0, Unicode and \s-1UTF\-8\s0\*(R".
.PP
Unicode digits may cause some confusion, and some security issues.  In \s-1UTF\-8\s0
strings, \f(CW\*(C`\ed\*(C'\fR matches the same characters matched by
\&\f(CW\*(C`\ep{General_Category=Decimal_Number}\*(C'\fR, or synonymously,
\&\f(CW\*(C`\ep{General_Category=Digit}\*(C'\fR.  Starting with Unicode version 4.1, this is the
same set of characters matched by \f(CW\*(C`\ep{Numeric_Type=Decimal}\*(C'\fR.
.PP
But Unicode also has a different property with a similar name,
\&\f(CW\*(C`\ep{Numeric_Type=Digit}\*(C'\fR, which matches a completely different set of
characters.  These characters are things such as subscripts.
.PP
The design intent is for \f(CW\*(C`\ed\*(C'\fR to match all the digits (and no other characters)
that can be used with \*(L"normal\*(R" big-endian positional decimal syntax, whereby a
sequence of such digits {N0, N1, N2, ...Nn} has the numeric value (...(N0 * 10
+ N1) * 10 + N2) * 10 ... + Nn).  In Unicode 5.2, the Tamil digits (U+0BE6 \-
U+0BEF) can also legally be used in old-style Tamil numbers in which they would
appear no more than one in a row, separated by characters that mean \*(L"times 10\*(R",
\&\*(L"times 100\*(R", etc.  (See <http://www.unicode.org/notes/tn21>.)
.PP
Some of the non-European digits that \f(CW\*(C`\ed\*(C'\fR matches look like European ones, but
have different values.  For example, \s-1BENGALI\s0 \s-1DIGIT\s0 \s-1FOUR\s0 (U+09A) looks very much
like an \s-1ASCII\s0 \s-1DIGIT\s0 \s-1EIGHT\s0 (U+0038).
.PP
It may be useful for security purposes for an application to require that all
digits in a row be from the same script.   See \*(L"\fIcharscript()\fR\*(R" in Unicode::UCD.
.PP
Any character that isn't matched by \f(CW\*(C`\ed\*(C'\fR will be matched by \f(CW\*(C`\eD\*(C'\fR.
.PP
\fIWord characters\fR
.IX Subsection "Word characters"
.PP
A \f(CW\*(C`\ew\*(C'\fR matches a single alphanumeric character (an alphabetic character, or a
decimal digit) or an underscore (\f(CW\*(C`_\*(C'\fR), not a whole word.  To match a whole
word, use \f(CW\*(C`\ew+\*(C'\fR.  This isn't the same thing as matching an English word, but 
is the same as a string of Perl-identifier characters.  What is considered a
word character depends on the internal
encoding of the string and the locale or \s-1EBCDIC\s0 code page that is in effect. If
it's in \s-1UTF\-8\s0 format, \f(CW\*(C`\ew\*(C'\fR matches those characters that are considered word
characters in the Unicode database. That is, it not only matches \s-1ASCII\s0 letters,
but also Thai letters, Greek letters, etc.  If the source string isn't in \s-1UTF\-8\s0
format, \f(CW\*(C`\ew\*(C'\fR matches those characters that are considered word characters by
the current locale or \s-1EBCDIC\s0 code page.  Without a locale or \s-1EBCDIC\s0 code page,
\&\f(CW\*(C`\ew\*(C'\fR matches the \s-1ASCII\s0 letters, digits and the underscore.
See \*(L"Locale, \s-1EBCDIC\s0, Unicode and \s-1UTF\-8\s0\*(R".
.PP
There are a number of security issues with the full Unicode list of word
characters.  See <http://unicode.org/reports/tr36>.
.PP
Also, for a somewhat finer-grained set of characters that are in programming
language identifiers beyond the \s-1ASCII\s0 range, you may wish to instead use the
more customized Unicode properties, \*(L"ID_Start\*(R", ID_Continue\*(L", \*(R"XID_Start\*(L", and
\&\*(R"XID_Continue".  See <http://unicode.org/reports/tr31>.
.PP
Any character that isn't matched by \f(CW\*(C`\ew\*(C'\fR will be matched by \f(CW\*(C`\eW\*(C'\fR.
.PP
\fIWhitespace\fR
.IX Subsection "Whitespace"
.PP
\&\f(CW\*(C`\es\*(C'\fR matches any single character that is considered whitespace.  The exact
set of characters matched by \f(CW\*(C`\es\*(C'\fR depends on whether the source string is in
\&\s-1UTF\-8\s0 format and the locale or \s-1EBCDIC\s0 code page that is in effect. If it's in
\&\s-1UTF\-8\s0 format, \f(CW\*(C`\es\*(C'\fR matches what is considered whitespace in the Unicode
database; the complete list is in the table below. Otherwise, if there is a
locale or \s-1EBCDIC\s0 code page in effect, \f(CW\*(C`\es\*(C'\fR matches whatever is considered
whitespace by the current locale or \s-1EBCDIC\s0 code page. Without a locale or
\&\s-1EBCDIC\s0 code page, \f(CW\*(C`\es\*(C'\fR matches the horizontal tab (\f(CW\*(C`\et\*(C'\fR), the newline
(\f(CW\*(C`\en\*(C'\fR), the form feed (\f(CW\*(C`\ef\*(C'\fR), the carriage return (\f(CW\*(C`\er\*(C'\fR), and the space.
(Note that it doesn't match the vertical tab, \f(CW\*(C`\ecK\*(C'\fR.)  Perhaps the most notable
possible surprise is that \f(CW\*(C`\es\*(C'\fR matches a non-breaking space only if the
non-breaking space is in a \s-1UTF\-8\s0 encoded string or the locale or \s-1EBCDIC\s0 code
page that is in effect has that character.
See \*(L"Locale, \s-1EBCDIC\s0, Unicode and \s-1UTF\-8\s0\*(R".
.PP
Any character that isn't matched by \f(CW\*(C`\es\*(C'\fR will be matched by \f(CW\*(C`\eS\*(C'\fR.
.PP
\&\f(CW\*(C`\eh\*(C'\fR will match any character that is considered horizontal whitespace;
this includes the space and the tab characters and a number other characters,
all of which are listed in the table below.  \f(CW\*(C`\eH\*(C'\fR will match any character
that is not considered horizontal whitespace.
.PP
\&\f(CW\*(C`\ev\*(C'\fR will match any character that is considered vertical whitespace;
this includes the carriage return and line feed characters (newline) plus several
other characters, all listed in the table below.
\&\f(CW\*(C`\eV\*(C'\fR will match any character that is not considered vertical whitespace.
.PP
\&\f(CW\*(C`\eR\*(C'\fR matches anything that can be considered a newline under Unicode
rules. It's not a character class, as it can match a multi-character
sequence. Therefore, it cannot be used inside a bracketed character
class; use \f(CW\*(C`\ev\*(C'\fR instead (vertical whitespace).
Details are discussed in perlrebackslash.
.PP
Note that unlike \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR and \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR always match
the same characters, regardless whether the source string is in \s-1UTF\-8\s0
format or not. The set of characters they match is also not influenced
by locale nor \s-1EBCDIC\s0 code page.
.PP
One might think that \f(CW\*(C`\es\*(C'\fR is equivalent to \f(CW\*(C`[\eh\ev]\*(C'\fR. This is not true.  The
vertical tab (\f(CW"\ex0b"\fR) is not matched by \f(CW\*(C`\es\*(C'\fR, it is however considered
vertical whitespace. Furthermore, if the source string is not in \s-1UTF\-8\s0 format,
and any locale or \s-1EBCDIC\s0 code page that is in effect doesn't include them, the
next line (ASCII-platform \f(CW"\ex85"\fR) and the no-break space (ASCII-platform
\&\f(CW"\exA0"\fR) characters are not matched by \f(CW\*(C`\es\*(C'\fR, but are by \f(CW\*(C`\ev\*(C'\fR and \f(CW\*(C`\eh\*(C'\fR
respectively.  If the source string is in \s-1UTF\-8\s0 format, both the next line and
the no-break space are matched by \f(CW\*(C`\es\*(C'\fR.
.PP
The following table is a complete listing of characters matched by
\&\f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR as of Unicode 5.2.
.PP
The first column gives the code point of the character (in hex format),
the second column gives the (Unicode) name. The third column indicates
by which class(es) the character is matched (assuming no locale or \s-1EBCDIC\s0 code
page is in effect that changes the \f(CW\*(C`\es\*(C'\fR matching).
.PP
.Vb 10
\& 0x00009        CHARACTER TABULATION   h s
\& 0x0000a              LINE FEED (LF)    vs
\& 0x0000b             LINE TABULATION    v
\& 0x0000c              FORM FEED (FF)    vs
\& 0x0000d        CARRIAGE RETURN (CR)    vs
\& 0x00020                       SPACE   h s
\& 0x00085             NEXT LINE (NEL)    vs  [1]
\& 0x000a0              NO\-BREAK SPACE   h s  [1]
\& 0x01680            OGHAM SPACE MARK   h s
\& 0x0180e   MONGOLIAN VOWEL SEPARATOR   h s
\& 0x02000                     EN QUAD   h s
\& 0x02001                     EM QUAD   h s
\& 0x02002                    EN SPACE   h s
\& 0x02003                    EM SPACE   h s
\& 0x02004          THREE\-PER\-EM SPACE   h s
\& 0x02005           FOUR\-PER\-EM SPACE   h s
\& 0x02006            SIX\-PER\-EM SPACE   h s
\& 0x02007                FIGURE SPACE   h s
\& 0x02008           PUNCTUATION SPACE   h s
\& 0x02009                  THIN SPACE   h s
\& 0x0200a                  HAIR SPACE   h s
\& 0x02028              LINE SEPARATOR    vs
\& 0x02029         PARAGRAPH SEPARATOR    vs
\& 0x0202f       NARROW NO\-BREAK SPACE   h s
\& 0x0205f   MEDIUM MATHEMATICAL SPACE   h s
\& 0x03000           IDEOGRAPHIC SPACE   h s
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\s-1NEXT\s0 \s-1LINE\s0 and NO-BREAK \s-1SPACE\s0 only match \f(CW\*(C`\es\*(C'\fR if the source string is in
\&\s-1UTF\-8\s0 format, or the locale or \s-1EBCDIC\s0 code page that is in effect includes them.
.PP
It is worth noting that \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, etc, match single characters, not
complete numbers or words. To match a number (that consists of integers),
use \f(CW\*(C`\ed+\*(C'\fR; to match a word, use \f(CW\*(C`\ew+\*(C'\fR.
.PP
\fI\eN\fR
.IX Subsection "N"
.PP
\&\f(CW\*(C`\eN\*(C'\fR is new in 5.12, and is experimental.  It, like the dot, will match any
character that is not a newline. The difference is that \f(CW\*(C`\eN\*(C'\fR is not influenced
by the \fIsingle line\fR regular expression modifier (see \*(L"The dot\*(R" above).  Note
that the form \f(CW\*(C`\eN{...}\*(C'\fR may mean something completely different.  When the
\&\f(CW\*(C`{...}\*(C'\fR is a quantifier, it means to match a non-newline
character that many times.  For example, \f(CW\*(C`\eN{3}\*(C'\fR means to match 3
non-newlines; \f(CW\*(C`\eN{5,}\*(C'\fR means to match 5 or more non-newlines.  But if \f(CW\*(C`{...}\*(C'\fR
is not a legal quantifier, it is presumed to be a named character.  See
charnames for those.  For example, none of \f(CW\*(C`\eN{COLON}\*(C'\fR, \f(CW\*(C`\eN{4F}\*(C'\fR, and
\&\f(CW\*(C`\eN{F4}\*(C'\fR contain legal quantifiers, so Perl will try to find characters whose
names are, respectively, \f(CW\*(C`COLON\*(C'\fR, \f(CW\*(C`4F\*(C'\fR, and \f(CW\*(C`F4\*(C'\fR.
.PP
\fIUnicode Properties\fR
.IX Subsection "Unicode Properties"
.PP
\&\f(CW\*(C`\epP\*(C'\fR and \f(CW\*(C`\ep{Prop}\*(C'\fR are character classes to match characters that fit given
Unicode properties.  One letter property names can be used in the \f(CW\*(C`\epP\*(C'\fR form,
with the property name following the \f(CW\*(C`\ep\*(C'\fR, otherwise, braces are required.
When using braces, there is a single form, which is just the property name
enclosed in the braces, and a compound form which looks like \f(CW\*(C`\ep{name=value}\*(C'\fR,
which means to match if the property \*(L"name\*(R" for the character has the particular
\&\*(L"value\*(R".
For instance, a match for a number can be written as \f(CW\*(C`/\epN/\*(C'\fR or as
\&\f(CW\*(C`/\ep{Number}/\*(C'\fR, or as \f(CW\*(C`/\ep{Number=True}/\*(C'\fR.
Lowercase letters are matched by the property \fILowercase_Letter\fR which
has as short form \fILl\fR. They need the braces, so are written as \f(CW\*(C`/\ep{Ll}/\*(C'\fR or
\&\f(CW\*(C`/\ep{Lowercase_Letter}/\*(C'\fR, or \f(CW\*(C`/\ep{General_Category=Lowercase_Letter}/\*(C'\fR
(the underscores are optional).
\&\f(CW\*(C`/\epLl/\*(C'\fR is valid, but means something different.
It matches a two character string: a letter (Unicode property \f(CW\*(C`\epL\*(C'\fR),
followed by a lowercase \f(CW\*(C`l\*(C'\fR.
.PP
For more details, see \*(L"Unicode Character Properties\*(R" in perlunicode; for a
complete list of possible properties, see
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops.
It is also possible to define your own properties. This is discussed in
\&\*(L"User-Defined Character Properties\*(R" in perlunicode.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 8
\& "a"  =~  /\ew/      # Match, "a" is a \*(Aqword\*(Aq character.
\& "7"  =~  /\ew/      # Match, "7" is a \*(Aqword\*(Aq character as well.
\& "a"  =~  /\ed/      # No match, "a" isn\*(Aqt a digit.
\& "7"  =~  /\ed/      # Match, "7" is a digit.
\& " "  =~  /\es/      # Match, a space is whitespace.
\& "a"  =~  /\eD/      # Match, "a" is a non\-digit.
\& "7"  =~  /\eD/      # No match, "7" is not a non\-digit.
\& " "  =~  /\eS/      # No match, a space is not non\-whitespace.
\&
\& " "  =~  /\eh/      # Match, space is horizontal whitespace.
\& " "  =~  /\ev/      # No match, space is not vertical whitespace.
\& "\er" =~  /\ev/      # Match, a return is vertical whitespace.
\&
\& "a"  =~  /\epL/     # Match, "a" is a letter.
\& "a"  =~  /\ep{Lu}/  # No match, /\ep{Lu}/ matches upper case letters.
\&
\& "\ex{0e0b}" =~ /\ep{Thai}/  # Match, \ex{0e0b} is the character
\&                           # \*(AqTHAI CHARACTER SO SO\*(Aq, and that\*(Aqs in
\&                           # Thai Unicode class.
\& "a"  =~  /\eP{Lao}/ # Match, as "a" is not a Laotian character.
.Ve
.SS "Bracketed Character Classes"
.IX Subsection "Bracketed Character Classes"
The third form of character class you can use in Perl regular expressions
is the bracketed character class.  In its simplest form, it lists the characters
that may be matched, surrounded by square brackets, like this: \f(CW\*(C`[aeiou]\*(C'\fR.
This matches one of \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, \f(CW\*(C`o\*(C'\fR or \f(CW\*(C`u\*(C'\fR.  Like the other
character classes, exactly one character will be matched. To match
a longer string consisting of characters mentioned in the character
class, follow the character class with a quantifier.  For
instance, \f(CW\*(C`[aeiou]+\*(C'\fR matches a string of one or more lowercase English vowels.
.PP
Repeating a character in a character class has no
effect; it's considered to be in the set only once.
.PP
Examples:
.PP
.Vb 5
\& "e"  =~  /[aeiou]/        # Match, as "e" is listed in the class.
\& "p"  =~  /[aeiou]/        # No match, "p" is not listed in the class.
\& "ae" =~  /^[aeiou]$/      # No match, a character class only matches
\&                           # a single character.
\& "ae" =~  /^[aeiou]+$/     # Match, due to the quantifier.
.Ve
.PP
\fISpecial Characters Inside a Bracketed Character Class\fR
.IX Subsection "Special Characters Inside a Bracketed Character Class"
.PP
Most characters that are meta characters in regular expressions (that
is, characters that carry a special meaning like \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`*\*(C'\fR, or \f(CW\*(C`(\*(C'\fR) lose
their special meaning and can be used inside a character class without
the need to escape them. For instance, \f(CW\*(C`[()]\*(C'\fR matches either an opening
parenthesis, or a closing parenthesis, and the parens inside the character
class don't group or capture.
.PP
Characters that may carry a special meaning inside a character class are:
\&\f(CW\*(C`\e\*(C'\fR, \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`[\*(C'\fR and \f(CW\*(C`]\*(C'\fR, and are discussed below. They can be
escaped with a backslash, although this is sometimes not needed, in which
case the backslash may be omitted.
.PP
The sequence \f(CW\*(C`\eb\*(C'\fR is special inside a bracketed character class. While
outside the character class, \f(CW\*(C`\eb\*(C'\fR is an assertion indicating a point
that does not have either two word characters or two non-word characters
on either side, inside a bracketed character class, \f(CW\*(C`\eb\*(C'\fR matches a
backspace character.
.PP
The sequences
\&\f(CW\*(C`\ea\*(C'\fR,
\&\f(CW\*(C`\ec\*(C'\fR,
\&\f(CW\*(C`\ee\*(C'\fR,
\&\f(CW\*(C`\ef\*(C'\fR,
\&\f(CW\*(C`\en\*(C'\fR,
\&\f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR,
\&\f(CW\*(C`\eN{U+\f(CIwide hex char\f(CW}\*(C'\fR,
\&\f(CW\*(C`\er\*(C'\fR,
\&\f(CW\*(C`\et\*(C'\fR,
and
\&\f(CW\*(C`\ex\*(C'\fR
are also special and have the same meanings as they do outside a bracketed character
class.
.PP
Also, a backslash followed by two or three octal digits is considered an octal
number.
.PP
A \f(CW\*(C`[\*(C'\fR is not special inside a character class, unless it's the start of a
\&\s-1POSIX\s0 character class (see \*(L"\s-1POSIX\s0 Character Classes\*(R" below). It normally does
not need escaping.
.PP
A \f(CW\*(C`]\*(C'\fR is normally either the end of a \s-1POSIX\s0 character class (see
\&\*(L"\s-1POSIX\s0 Character Classes\*(R" below), or it signals the end of the bracketed
character class.  If you want to include a \f(CW\*(C`]\*(C'\fR in the set of characters, you
must generally escape it.
However, if the \f(CW\*(C`]\*(C'\fR is the \fIfirst\fR (or the second if the first
character is a caret) character of a bracketed character class, it
does not denote the end of the class (as you cannot have an empty class)
and is considered part of the set of characters that can be matched without
escaping.
.PP
Examples:
.PP
.Vb 8
\& "+"   =~ /[+?*]/     #  Match, "+" in a character class is not special.
\& "\ecH" =~ /[\eb]/      #  Match, \eb inside in a character class
\&                      #  is equivalent to a backspace.
\& "]"   =~ /[][]/      #  Match, as the character class contains.
\&                      #  both [ and ].
\& "[]"  =~ /[[]]/      #  Match, the pattern contains a character class
\&                      #  containing just ], and the character class is
\&                      #  followed by a ].
.Ve
.PP
\fICharacter Ranges\fR
.IX Subsection "Character Ranges"
.PP
It is not uncommon to want to match a range of characters. Luckily, instead
of listing all the characters in the range, one may use the hyphen (\f(CW\*(C`\-\*(C'\fR).
If inside a bracketed character class you have two characters separated
by a hyphen, it's treated as if all the characters between the two are in
the class. For instance, \f(CW\*(C`[0\-9]\*(C'\fR matches any \s-1ASCII\s0 digit, and \f(CW\*(C`[a\-m]\*(C'\fR
matches any lowercase letter from the first half of the \s-1ASCII\s0 alphabet.
.PP
Note that the two characters on either side of the hyphen are not
necessary both letters or both digits. Any character is possible,
although not advisable.  \f(CW\*(C`[\*(Aq\-?]\*(C'\fR contains a range of characters, but
most people will not know which characters that will be. Furthermore,
such ranges may lead to portability problems if the code has to run on
a platform that uses a different character set, such as \s-1EBCDIC\s0.
.PP
If a hyphen in a character class cannot syntactically be part of a range, for
instance because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and will be
considered a character that is to be matched literally. You have to escape the
hyphen with a backslash if you want to have a hyphen in your set of characters
to be matched, and its position in the class is such that it could be
considered part of a range.
.PP
Examples:
.PP
.Vb 8
\& [a\-z]       #  Matches a character that is a lower case ASCII letter.
\& [a\-fz]      #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive) or
\&             #  the letter \*(Aqz\*(Aq.
\& [\-z]        #  Matches either a hyphen (\*(Aq\-\*(Aq) or the letter \*(Aqz\*(Aq.
\& [a\-f\-m]     #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive), the
\&             #  hyphen (\*(Aq\-\*(Aq), or the letter \*(Aqm\*(Aq.
\& [\*(Aq\-?]       #  Matches any of the characters  \*(Aq()*+,\-./0123456789:;<=>?
\&             #  (But not on an EBCDIC platform).
.Ve
.PP
\fINegation\fR
.IX Subsection "Negation"
.PP
It is also possible to instead list the characters you do not want to
match. You can do so by using a caret (\f(CW\*(C`^\*(C'\fR) as the first character in the
character class. For instance, \f(CW\*(C`[^a\-z]\*(C'\fR matches a character that is not a
lowercase \s-1ASCII\s0 letter.
.PP
This syntax make the caret a special character inside a bracketed character
class, but only if it is the first character of the class. So if you want
to have the caret as one of the characters you want to match, you either
have to escape the caret, or not list it first.
.PP
Examples:
.PP
.Vb 4
\& "e"  =~  /[^aeiou]/   #  No match, the \*(Aqe\*(Aq is listed.
\& "x"  =~  /[^aeiou]/   #  Match, as \*(Aqx\*(Aq isn\*(Aqt a lowercase vowel.
\& "^"  =~  /[^^]/       #  No match, matches anything that isn\*(Aqt a caret.
\& "^"  =~  /[x^]/       #  Match, caret is not special here.
.Ve
.PP
\fIBackslash Sequences\fR
.IX Subsection "Backslash Sequences"
.PP
You can put any backslash sequence character class (with the exception of
\&\f(CW\*(C`\eN\*(C'\fR) inside a bracketed character class, and it will act just
as if you put all the characters matched by the backslash sequence inside the
character class. For instance, \f(CW\*(C`[a\-f\ed]\*(C'\fR will match any decimal digit, or any
of the lowercase letters between 'a' and 'f' inclusive.
.PP
\&\f(CW\*(C`\eN\*(C'\fR within a bracketed character class must be of the forms \f(CW\*(C`\eN{\f(CIname\f(CW}\*(C'\fR
or \f(CW\*(C`\eN{U+\f(CIwide hex char\f(CW}\*(C'\fR, and \s-1NOT\s0 be the form that matches non-newlines,
for the same reason that a dot \f(CW\*(C`.\*(C'\fR inside a bracketed character class loses
its special meaning: it matches nearly anything, which generally isn't what you
want to happen.
.PP
Examples:
.PP
.Vb 4
\& /[\ep{Thai}\ed]/     # Matches a character that is either a Thai
\&                    # character, or a digit.
\& /[^\ep{Arabic}()]/  # Matches a character that is neither an Arabic
\&                    # character, nor a parenthesis.
.Ve
.PP
Backslash sequence character classes cannot form one of the endpoints
of a range.  Thus, you can't say:
.PP
.Vb 1
\& /[\ep{Thai}\-\ed]/     # Wrong!
.Ve
.PP
\fI\s-1POSIX\s0 Character Classes\fR
.IX Xref "character class \\p \\p{} alpha alnum ascii blank cntrl digit graph lower print punct space upper word xdigit"
.IX Subsection "POSIX Character Classes"
.PP
\&\s-1POSIX\s0 character classes have the form \f(CW\*(C`[:class:]\*(C'\fR, where \fIclass\fR is
name, and the \f(CW\*(C`[:\*(C'\fR and \f(CW\*(C`:]\*(C'\fR delimiters. \s-1POSIX\s0 character classes only appear
\&\fIinside\fR bracketed character classes, and are a convenient and descriptive
way of listing a group of characters, though they currently suffer from
portability issues (see below and \*(L"Locale, \s-1EBCDIC\s0, Unicode and \s-1UTF\-8\s0\*(R").
.PP
Be careful about the syntax,
.PP
.Vb 2
\& # Correct:
\& $string =~ /[[:alpha:]]/
\&
\& # Incorrect (will warn):
\& $string =~ /[:alpha:]/
.Ve
.PP
The latter pattern would be a character class consisting of a colon,
and the letters \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR and \f(CW\*(C`h\*(C'\fR.
\&\s-1POSIX\s0 character classes can be part of a larger bracketed character class.  For
example,
.PP
.Vb 1
\& [01[:alpha:]%]
.Ve
.PP
is valid and matches '0', '1', any alphabetic character, and the percent sign.
.PP
Perl recognizes the following \s-1POSIX\s0 character classes:
.PP
.Vb 10
\& alpha  Any alphabetical character ("[A\-Za\-z]").
\& alnum  Any alphanumerical character. ("[A\-Za\-z0\-9]")
\& ascii  Any character in the ASCII character set.
\& blank  A GNU extension, equal to a space or a horizontal tab ("\et").
\& cntrl  Any control character.  See Note [2] below.
\& digit  Any decimal digit ("[0\-9]"), equivalent to "\ed".
\& graph  Any printable character, excluding a space.  See Note [3] below.
\& lower  Any lowercase character ("[a\-z]").
\& print  Any printable character, including a space.  See Note [4] below.
\& punct  Any graphical character excluding "word" characters.  Note [5].
\& space  Any whitespace character. "\es" plus the vertical tab ("\ecK").
\& upper  Any uppercase character ("[A\-Z]").
\& word   A Perl extension ("[A\-Za\-z0\-9_]"), equivalent to "\ew".
\& xdigit Any hexadecimal digit ("[0\-9a\-fA\-F]").
.Ve
.PP
Most \s-1POSIX\s0 character classes have two Unicode-style \f(CW\*(C`\ep\*(C'\fR property
counterparts.  (They are not official Unicode properties, but Perl extensions
derived from official Unicode properties.)  The table below shows the relation
between \s-1POSIX\s0 character classes and these counterparts.
.PP
One counterpart, in the column labelled \*(L"ASCII-range Unicode\*(R" in
the table, will only match characters in the \s-1ASCII\s0 character set.
.PP
The other counterpart, in the column labelled \*(L"Full-range Unicode\*(R", matches any
appropriate characters in the full Unicode character set.  For example,
\&\f(CW\*(C`\ep{Alpha}\*(C'\fR will match not just the \s-1ASCII\s0 alphabetic characters, but any
character in the entire Unicode character set that is considered to be
alphabetic.
.PP
(Each of the counterparts has various synonyms as well.
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops lists all the
synonyms, plus all the characters matched by each of the ASCII-range
properties.  For example \f(CW\*(C`\ep{AHex}\*(C'\fR is a synonym for \f(CW\*(C`\ep{ASCII_Hex_Digit}\*(C'\fR,
and any \f(CW\*(C`\ep\*(C'\fR property name can be prefixed with \*(L"Is\*(R" such as \f(CW\*(C`\ep{IsAlpha}\*(C'\fR.)
.PP
Both the \f(CW\*(C`\ep\*(C'\fR forms are unaffected by any locale that is in effect, or whether
the string is in \s-1UTF\-8\s0 format or not, or whether the platform is \s-1EBCDIC\s0 or not.
In contrast, the \s-1POSIX\s0 character classes are affected.  If the source string is
in \s-1UTF\-8\s0 format, the \s-1POSIX\s0 classes (with the exception of \f(CW\*(C`[[:punct:]]\*(C'\fR, see
Note [5] below) behave like their \*(L"Full-range\*(R" Unicode counterparts.  If the
source string is not in \s-1UTF\-8\s0 format, and no locale is in effect, and the
platform is not \s-1EBCDIC\s0, all the \s-1POSIX\s0 classes behave like their ASCII-range
counterparts.  Otherwise, they behave based on the rules of the locale or
\&\s-1EBCDIC\s0 code page.
.PP
It is proposed to change this behavior in a future release of Perl so that the
the UTF8ness of the source string will be irrelevant to the behavior of the
\&\s-1POSIX\s0 character classes.  This means they will always behave in strict
accordance with the official \s-1POSIX\s0 standard.  That is, if either locale or
\&\s-1EBCDIC\s0 code page is present, they will behave in accordance with those; if
absent, the classes will match only their ASCII-range counterparts.  If you
disagree with this proposal, send email to \f(CW\*(C`perl5\-porters@perl.org\*(C'\fR.
.PP
.Vb 10
\& [[:...:]]      ASCII\-range        Full\-range  backslash  Note
\&                 Unicode            Unicode    sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   alpha      \ep{PosixAlpha}       \ep{Alpha}
\&   alnum      \ep{PosixAlnum}       \ep{Alnum}
\&   ascii      \ep{ASCII}          
\&   blank      \ep{PosixBlank}       \ep{Blank} =             [1]
\&                                   \ep{HorizSpace}  \eh      [1]
\&   cntrl      \ep{PosixCntrl}       \ep{Cntrl}               [2]
\&   digit      \ep{PosixDigit}       \ep{Digit}       \ed
\&   graph      \ep{PosixGraph}       \ep{Graph}               [3]
\&   lower      \ep{PosixLower}       \ep{Lower}
\&   print      \ep{PosixPrint}       \ep{Print}               [4]
\&   punct      \ep{PosixPunct}       \ep{Punct}               [5]
\&              \ep{PerlSpace}        \ep{SpacePerl}   \es      [6]
\&   space      \ep{PosixSpace}       \ep{Space}               [6]
\&   upper      \ep{PosixUpper}       \ep{Upper}
\&   word       \ep{PerlWord}         \ep{Word}        \ew
\&   xdigit     \ep{ASCII_Hex_Digit}  \ep{XDigit}
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\f(CW\*(C`\ep{Blank}\*(C'\fR and \f(CW\*(C`\ep{HorizSpace}\*(C'\fR are synonyms.
.IP "[2]" 4
.IX Item "[2]"
Control characters don't produce output as such, but instead usually control
the terminal somehow: for example newline and backspace are control characters.
In the \s-1ASCII\s0 range, characters whose ordinals are between 0 and 31 inclusive,
plus 127 (\f(CW\*(C`DEL\*(C'\fR) are control characters.
.Sp
On \s-1EBCDIC\s0 platforms, it is likely that the code page will define \f(CW\*(C`[[:cntrl:]]\*(C'\fR
to be the \s-1EBCDIC\s0 equivalents of the \s-1ASCII\s0 controls, plus the controls
that in Unicode have ordinals from 128 through 159.
.IP "[3]" 4
.IX Item "[3]"
Any character that is \fIgraphical\fR, that is, visible. This class consists
of all the alphanumerical characters and all punctuation characters.
.IP "[4]" 4
.IX Item "[4]"
All printable characters, which is the set of all the graphical characters
plus whitespace characters that are not also controls.
.IP "[5] (punct)" 4
.IX Item "[5] (punct)"
\&\f(CW\*(C`\ep{PosixPunct}\*(C'\fR and \f(CW\*(C`[[:punct:]]\*(C'\fR in the \s-1ASCII\s0 range match all the
non-controls, non-alphanumeric, non-space characters:
\&\f(CW\*(C`[\-!"#$%&\*(Aq()*+,./:;<=>?@[\e\e\e]^_\`{|}~]\*(C'\fR (although if a locale is in effect,
it could alter the behavior of \f(CW\*(C`[[:punct:]]\*(C'\fR).
.Sp
\&\f(CW\*(C`\ep{Punct}\*(C'\fR matches a somewhat different set in the \s-1ASCII\s0 range, namely
\&\f(CW\*(C`[\-!"#%&\*(Aq()*,./:;?@[\e\e\e]_{}]\*(C'\fR.  That is, it is missing \f(CW\*(C`[$+<=>^\`|~]\*(C'\fR.
This is because Unicode splits what \s-1POSIX\s0 considers to be punctuation into two
categories, Punctuation and Symbols.
.Sp
When the matching string is in \s-1UTF\-8\s0 format, \f(CW\*(C`[[:punct:]]\*(C'\fR matches what it
matches in the \s-1ASCII\s0 range, plus what \f(CW\*(C`\ep{Punct}\*(C'\fR matches.  This is different
than strictly matching according to \f(CW\*(C`\ep{Punct}\*(C'\fR.  Another way to say it is that
for a \s-1UTF\-8\s0 string, \f(CW\*(C`[[:punct:]]\*(C'\fR matches all the characters that Unicode
considers to be punctuation, plus all the ASCII-range characters that Unicode
considers to be symbols.
.IP "[6]" 4
.IX Item "[6]"
\&\f(CW\*(C`\ep{SpacePerl}\*(C'\fR and \f(CW\*(C`\ep{Space}\*(C'\fR differ only in that \f(CW\*(C`\ep{Space}\*(C'\fR additionally
matches the vertical tab, \f(CW\*(C`\ecK\*(C'\fR.   Same for the two ASCII-only range forms.
.PP
Negation
.IX Xref "character class, negation"
.IX Subsection "Negation"
.PP
A Perl extension to the \s-1POSIX\s0 character class is the ability to
negate it. This is done by prefixing the class name with a caret (\f(CW\*(C`^\*(C'\fR).
Some examples:
.PP
.Vb 7
\&     POSIX         ASCII\-range     Full\-range  backslash
\&                    Unicode         Unicode    sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& [[:^digit:]]   \eP{PosixDigit}     \eP{Digit}      \eD
\& [[:^space:]]   \eP{PosixSpace}     \eP{Space}
\&                \eP{PerlSpace}      \eP{SpacePerl}  \eS
\& [[:^word:]]    \eP{PerlWord}       \eP{Word}       \eW
.Ve
.PP
[= =] and [. .]
.IX Subsection "[= =] and [. .]"
.PP
Perl will recognize the \s-1POSIX\s0 character classes \f(CW\*(C`[=class=]\*(C'\fR, and
\&\f(CW\*(C`[.class.]\*(C'\fR, but does not (yet?) support them.  Use of
such a construct will lead to an error.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 12
\& /[[:digit:]]/            # Matches a character that is a digit.
\& /[01[:lower:]]/          # Matches a character that is either a
\&                          # lowercase letter, or \*(Aq0\*(Aq or \*(Aq1\*(Aq.
\& /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything
\&                          # except the letters \*(Aqa\*(Aq to \*(Aqf\*(Aq.  This is
\&                          # because the main character class is composed
\&                          # of two POSIX character classes that are ORed
\&                          # together, one that matches any digit, and
\&                          # the other that matches anything that isn\*(Aqt a
\&                          # hex digit.  The result matches all
\&                          # characters except the letters \*(Aqa\*(Aq to \*(Aqf\*(Aq and
\&                          # \*(AqA\*(Aq to \*(AqF\*(Aq.
.Ve
.SS "Locale, \s-1EBCDIC\s0, Unicode and \s-1UTF\-8\s0"
.IX Subsection "Locale, EBCDIC, Unicode and UTF-8"
Some of the character classes have a somewhat different behaviour depending
on the internal encoding of the source string, and the locale that is
in effect, and if the program is running on an \s-1EBCDIC\s0 platform.
.PP
\&\f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR and the \s-1POSIX\s0 character classes (and their negations,
including \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR) suffer from this behaviour.  (Since the backslash
sequences \f(CW\*(C`\eb\*(C'\fR and \f(CW\*(C`\eB\*(C'\fR are defined in terms of \f(CW\*(C`\ew\*(C'\fR and \f(CW\*(C`\eW\*(C'\fR, they also are
affected.)
.PP
The rule is that if the source string is in \s-1UTF\-8\s0 format, the character
classes match according to the Unicode properties. If the source string
isn't, then the character classes match according to whatever locale or \s-1EBCDIC\s0
code page is in effect. If there is no locale nor \s-1EBCDIC\s0, they match the \s-1ASCII\s0
defaults (0 to 9 for \f(CW\*(C`\ed\*(C'\fR; 52 letters, 10 digits and underscore for \f(CW\*(C`\ew\*(C'\fR;
etc.).
.PP
This usually means that if you are matching against characters whose \f(CW\*(C`ord()\*(C'\fR
values are between 128 and 255 inclusive, your character class may match
or not depending on the current locale or \s-1EBCDIC\s0 code page, and whether the
source string is in \s-1UTF\-8\s0 format. The string will be in \s-1UTF\-8\s0 format if it
contains characters whose \f(CW\*(C`ord()\*(C'\fR value exceeds 255. But a string may be in
\&\s-1UTF\-8\s0 format without it having such characters.  See \*(L"The
\&\*(R"Unicode Bug"" in perlunicode.
.PP
For portability reasons, it may be better to not use \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR
or the \s-1POSIX\s0 character classes, and use the Unicode properties instead.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 6
\& $str =  "\exDF";      # $str is not in UTF\-8 format.
\& $str =~ /^\ew/;       # No match, as $str isn\*(Aqt in UTF\-8 format.
\& $str .= "\ex{0e0b}";  # Now $str is in UTF\-8 format.
\& $str =~ /^\ew/;       # Match! $str is now in UTF\-8 format.
\& chop $str;
\& $str =~ /^\ew/;       # Still a match! $str remains in UTF\-8 format.
.Ve
